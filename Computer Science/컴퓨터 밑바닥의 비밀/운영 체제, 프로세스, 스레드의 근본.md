# CPU

- CPU는 메모리에서 명령어(instruction) 하나를 가져와서(dispatch) 실행(execute)한 후 다음에 실행할 명령어를 가져온다. (명령어 인출 - 명령어 실행 - 명령어 인출...)
- 프로그램 카운터(program counter): 용량은 작지만 속도는 매우 빠른 일종의 메모리. CPU 내부에 있는 일종의 레지스터(register)로, CPU가 다음에 실행할 메모리에 저장된 명령어의 주소를 가지고 있다. 
- PC Register가 저장하는 주소는 기본적으로 1씩 자동으로 증가한다. 대부분 CPU가 주소를 하나씩 증가시키면서 차례대로 명령어를 실행하기 때문에 순차적인 동작 방식은 일리가 있다. 하지만 if else 또는 함수 호출 같은 명령어를 만나면 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 PC 레지스터 값을 동적으로 변경한다. 이런 방식으로 CPU는 실행해야 할 명령어로 정확하게 점프한다. 
- 프로그래머가 작성한 소스 파일 -(컴파일러)> 디스크의 실행 파일 -(메모리에 적재)> 메모리에 저장된 명령어 -> PC Register에 실행할 메모리 주소 저장 -> CPU가 가져와 실행
- 최초의 PC Register 값 설정: 프로그램이 시작되면 먼저 main 함수에 대응하는 첫 번째 기계 명령어를 찾고, 이어서 그 메모리 주소를 PC 레지스터에 기록한다. 물론 main 함수를 실제로 실행하기 전에 일부 레지스터의 초기화처럼 별도의 초기화 과정이 진행된다.

### CPU에서 운영 체제까지
- CPU가 프로그램을 실행하게 하려면 디스크에 저장된 실행 파일을 수동으로 메모리에 복사한 다음 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다. 하지만 이렇게 하면 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)을 찾아 PC register를 설정하는 등을 작업을 개발자가 직접 해야 한다. 이렇게 수동적으로 프로그램을 실행하면 단점이 있는데: 한 번에 하나의 프로그램만 실행할 수 있다; 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없다 - 네트워크 통신하려면 TCP/IP 스택 소스 코드에도 연결해야 한다; 운영체제가 제공하는 라이브러리 지원을 받을 수 없어서 직접 다 만들어야 한다; 상호 작용 인터페이스(interactive interface)를 원하면 직접 다 구현해야 한다. 
- CPU는 한 번에 한 가지 일만 할 수 있기 때문에, 프로그램 A의 기계 명령어를 실행하거나 프로그램 B의 기계 명령어를 실행하는 것 중 하나만 할 수 있다. 때문에 프로그램 A, B가 동시에 실행되는 것처럼 보이게 하려면 CPU의 전환 빈도를 충분히 빠르게 하면 된다. 
- 이때 CPU가 전환을 하려면 어떤 기계 명령어를 실행했는지와 CPU 내부의 기타 레지스터 값 등 상태 값에 대한 정보를 저장해두고 있어야 하는데, 이때 저장되는 상태를 상황 정보(context)라고 하고, 프로그램이 이 실행 중인 모든 정보를 기록할 수 있는 이런 형태의 구조체를 가지게 되면 프로세스(process)가 된다. 
- 따라서 모든 프로그램은 실행된 후에 프로세스 형태로 관리되고, 원하는 대로 일시 중지하거나 다시 시작할 수 있다. 
- 운영 체제(operating system)은 프로그램을 자동으로 적재해 주는 적재 도구와 멀티태스킹을 실현해주는 프로세스 관리 도구 등 여러 가지 기반 기능의 프로그램을 모아 둔 프로그램이다. 운영체제가 탄생함으로써 프로그래머는 더 이상 실행 파일을 수동으로 적재하거나 프로그램을 수동으로 유지 관리할 필요가 없어졌다. 운영 체제가 모든 것을 뒤(background)에서 처리해 주기 때문에, 시스템에서 실제로 실행 중인 타 프로세스가 몇 개인지, CPU가 몇 개인지, 물리 메모리의 용량이 얼마인지 신경 쓰지 않고 간단하게 내가 지금 사용하는 프로그램이 CPU와 표준 크기의 메모리를 독점하고 있다고 가정할 수 있다. 

### 프로세스는 훌륭하지만 아직 불편하다
- 운영 체제의 가상 메모리는 각각의 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 한다.
- 표준적인 메모리 공간, 즉, 프로세스 주소 공간(process address space)은 네 영역으로 나눌 수 있다:
1) 코드 영역(code segment): 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
2) 데이터 영역(data segment): 전역 변수 등이 저장된다.
3) 힙 영역(heap segment): malloc 함수가 요청을 반환한 메모리가 여기에 할당된다.
4) 스택 영역(stack segment): 함수의 실행 시간 스택이다.
- 만약 함수A와 함수B를 실행시키고 두 개의 함수의 결과를 합치는 하나의 실행 흐름(flow of execution)에서 총 실행 속도를 높이려면 프로세스A와 프로세스B를 생성해서 각각 funA와 funB의 결과를 얻은 후에 프로세스B의 결과를 프로세스A에 전달해서 값 두 개를 더하는 것인데, 이는 다중 프로세스 프로그래밍(multi-process programming)의 프로세스 간 통신(inter-process communication)이다. 그런데 이 다중 프로세스 프로그래밍에는 단점이 있다: 1) 프로세스를 생성할 때 드는 비교적 큰 부담(overhead), 그리고 2) 프로세스마다 자체적인 주소 공간을 가지고 있기에 프로세스 간 통신은 프로그래밍하기에 복잡하다는 점. 


### 프로세스에서 스레드로
- 프로스의 주소 공간에는 CPU가 실행되는 기계 명령어와, 함수가 실행될 때 스택 정보가 저장된다. 그리고 프로세스를 실행하려면 main 함수의 첫 번째 기계 명령어 주소를 PC 레지스터에 기록해야 한다. 이 과정을 거치면 명령어 실행 흐름이 생성된다.
- PC 레지스터가 main 함수를 가르키게 할 수 있듯이, 다른 함수를 가리키게 할 수 있으며, 이를 통해 새로운 실행 흐름을 형성할 수 있다. 이런 실행 흐름은 동일한 프로세스 주소 공간을 공유하므로, 더 이상 프로세스 간 통신이 필요하지 않다. 즉, CPU 여러 개가 동일한 프로세스의 기계 명령어를 실행하도록 할 수 있다. 다시 말해, 하나의 프로세스에 진입 함수가 두 개 이상 있을 수 있고, 하나의 프로세스에 속한 기계 명령어를 CPU 여러 개에서 동시에 실행할 수 있다. 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 명령어를 동시에 실행할 수 있는 것이다.
- 하나의 프로세스 안에 여러 실행 흐름이 존재할 수 있고, 이 실행 흐름을 스레드(thread)라고 한다. 
- 스레드는 동일한 프로세스 주소 공간에 속해 있기 때문에 자신이 속한 프로세스의 주소 공간을 공유하며, 따라서 통신이라는 개념이 필요가 없다. 이는 스레드가 프로세스보다 훨씬 가볍고 생성 속도가 빠르다: 때문에 스레드를 종종 경량 프로세스(light-weight process)라고 한다. 
- 프로세스를 시작하고 스레드 여러 개를 생성하기만 함녀 다중 코어를 이용하여 모든 CPU를 최대한 활용할 수 있고, 이것이 바로 고성능과 높은 동시성의 기초가 된다. 하지만 다중 코어가 있어야만 다중 스레드(multi-threading)을 사용할 수 있는 것은 아니며, 단일 코어인 상황에서도 스레드 여러 개를 생성할 수 있다. 스레드가 운영 체제 계층에 구현되며, 코어 개수와는 무관하기 때문이다. 
- CPU가 기계 명령어를 실행할 때 실행 중인 기계 명령어가 어떤 스레드에 속해 있는지 인식하지 못한다. 또 스레드에는 다중 코어를 충분히 활용하는 것 외에도 다른 용도가 있다. 예를 들어서 그래픽 사용자 인터페이스 프로그래밍을 할 때 특정 이벤트를 처리하는 데 많은 시간이 필요하여 응답이 없는 상황을 방지하고자 해당 이벤트를 처리하는 별도의 스레드를 생성할 수 있다. 
- 각 스레드가 프로세스의 메모리 주소 공간을 공유하기 때문에, 자연스럽게 스레드 간 '통신'을 위한 운영 체제의 지원도 필요하지 않다. 하지만 동시에 다중 스레드가 공유 리소스에 접근할 때 오류가 발생할 수 있다 ㅡ CPU가 명령어를 실행할 때 스레드를 전혀 고려하지 않기 때문이다. 따라서 프로그래머는 상호 배제(mutual exclusion)과 동기화(synchronization)을 이용하여 다중 스레드 공유 리소스, 문제를 명시적으로 직접 해결해야 한다. 

---
## CPU와 PC Register, 그리고 Thread
CPU의 스레드 스케줄링과 컨텍스트 스위칭

스레드 스케줄링 (Thread Scheduling):
운영 체제의 스케줄러는 CPU의 사용을 여러 스레드 사이에 나누어 할당합니다. 이 과정에서 각 스레드가 실행될 때 CPU를 사용할 수 있도록 합니다.
CPU는 특정 시간 동안 하나의 스레드를 실행하고, 그 후 다른 스레드를 실행하는 방식으로 스레드 간에 CPU 시간을 분배합니다.

컨텍스트 스위칭 (Context Switching):
컨텍스트 스위칭은 CPU가 현재 실행 중인 스레드의 상태(레지스터 값, 프로그램 카운터(PC), 스택 포인터 등)를 저장하고, 다음에 실행할 스레드의 상태를 불러오는 과정입니다.
스레드의 상태는 해당 스레드가 다시 실행될 때 이어서 작업을 수행할 수 있도록, 운영 체제가 메모리에 저장합니다.
이 과정은 매우 빠르게 일어나기 때문에, 사용자나 프로그램은 여러 스레드가 동시에 실행되는 것처럼 보이게 됩니다. 하지만 실제로는 CPU가 한 스레드에서 다른 스레드로 매우 빠르게 전환하면서 실행을 관리하고 있는 것입니다.

PC 레지스터와 스레드:
PC 레지스터는 현재 실행 중인 스레드가 다음에 실행할 명령어의 주소를 저장합니다.
스레드가 실행될 때, CPU는 해당 스레드의 PC 레지스터를 읽고 다음 명령어를 실행합니다.
컨텍스트 스위칭 시, 현재 스레드의 PC 레지스터 값을 저장하고, 다음에 실행할 스레드의 PC 레지스터 값을 복원함으로써 실행 흐름을 이어갑니다.

요약
CPU는 한 번에 하나의 스레드만 실행할 수 있습니다.
여러 스레드가 동시에 실행되는 것처럼 보이기 위해, CPU는 매우 빠른 속도로 여러 스레드 간의 컨텍스트를 스위칭합니다.
이 스위칭 과정에서 각 스레드의 상태(특히 PC 레지스터 값 등)를 저장하고 복원하여, 각 스레드가 마치 동시에 실행되는 것처럼 느껴지게 합니다.
결과적으로, 여러 스레드가 CPU를 공유하면서 작업을 수행하게 되며, 사용자에게는 여러 스레드가 동시에 실행되는 것처럼 보이게 됩니다.

이 방식 덕분에 단일 CPU 시스템에서도 여러 스레드가 병렬로 작업을 수행하는 것처럼 보이게 할 수 있습니다.

스레드가 여러 실행 흐름을 가질 수 있다는 것은, 각 스레드가 독립적인 PC 레지스터(Program Counter) 값을 가지고 있다는 의미입니다. 이 PC 레지스터는 현재 스레드가 실행 중인 명령어(또는 함수)의 메모리 주소를 가리키고 있습니다. 따라서, 스레드마다 PC 레지스터가 가리키는 위치가 다를 수 있으며, 이로 인해 각 스레드가 서로 다른 코드를 실행할 수 있게 됩니다.

요약하자면:

•PC 레지스터의 역할: 각 스레드는 고유한 PC 레지스터 값을 가지고 있으며, 이 값은 해당 스레드가 현재 실행 중인 명령어 또는 함수의 위치를 가리킵니다.
•다양한 실행 흐름: 다중 스레드 환경에서는 각 스레드가 서로 다른 PC 레지스터 값을 가질 수 있으므로, 서로 다른 함수나 코드의 부분을 동시에 실행할 수 있습니다.
•동시성의 구현: 이로 인해, 다중 스레드 프로그램은 여러 실행 흐름을 가지게 되며, 이는 마치 여러 작업이 동시에 이루어지는 것처럼 보이게 합니다.

따라서, 여러 스레드를 사용하여 다양한 실행 흐름을 구현할 수 있다는 것은 곧 여러 PC 레지스터가 서로 다른 위치를 가리키면서 독립적으로 작업을 수행할 수 있다는 것을 의미합니다.


**실행 흐름(Execution Flow)** 은 컴퓨터 프로그램이 실행되는 동안 명령어들이 순차적으로 처리되는 과정을 의미합니다. 실행 흐름은 프로그램의 논리적인 진행 경로로, 프로그램의 코드가 시작부터 끝까지 어떻게 실행되는지를 나타냅니다.

구체적인 설명

1.	순차적인 실행:
- 대부분의 프로그램은 순차적으로 실행됩니다. 즉, 코드의 첫 번째 줄부터 마지막 줄까지 차례대로 실행됩니다. 이 순차적인 흐름이 바로 실행 흐름입니다.
- 예를 들어, main() 함수에서 시작된 프로그램은 첫 번째 명령어부터 차례로 실행되면서 프로그램의 상태를 변화시킵니다.
2. 제어 구조와 실행 흐름:
- 조건문(If-Else): 조건에 따라 실행 흐름이 다른 경로로 분기됩니다. 예를 들어, if 조건이 참이면 한 블록의 코드가 실행되고, 거짓이면 다른 블록이 실행됩니다.
- 반복문(For, While): 특정 조건이 만족될 때까지 코드 블록을 반복하여 실행하는 제어 구조입니다. 반복문의 조건이 충족될 때마다 동일한 코드가 반복 실행되며, 이 역시 실행 흐름의 일부입니다.
- 함수 호출: 프로그램이 함수나 메서드를 호출할 때, 실행 흐름이 해당 함수로 이동한 뒤, 함수의 실행이 끝나면 원래 호출한 위치로 돌아옵니다. 이 과정 역시 실행 흐름을 정의합니다.
3. 다중 실행 흐름:
- 스레드: 다중 스레드를 사용하는 프로그램에서는 여러 실행 흐름이 동시에 존재할 수 있습니다. 각 스레드는 독립적인 실행 흐름을 가지며, 서로 다른 코드 조각을 동시에 실행할 수 있습니다.
- 비동기 처리: 비동기 작업은 메인 실행 흐름과는 별도로 실행되는 흐름을 만듭니다. 예를 들어, 네트워크 요청을 보내고 그 응답을 기다리는 동안, 메인 실행 흐름은 중단되지 않고 다른 작업을 계속 수행할 수 있습니다.
- 실행 흐름의 제어:
프로그램에서 실행 흐름을 제어하는 것은 매우 중요합니다. 이는 프로그램의 논리적 구조를 정의하고, 다양한 조건과 상황에 맞게 코드가 실행되도록 합니다.
실행 흐름을 제어하지 않으면 프로그램이 예상치 못한 동작을 할 수 있으며, 특히 다중 스레드 환경에서는 동시성 문제로 인해 실행 흐름의 정확한 제어가 필요합니다.
---

### 다중 스레드와 메모리 구조
- CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행시킬 수 있다. 
- 함수가 실행될 때 필요한 정보는 함수의 매개변수(parameter), 지역 변수, 반환 주소(return address) 등이 있다. 이런 정보는 스택 프레임(stack frame)에 저장되며, 모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임(runtime stack frame)을 가진다. 함수가 호출되고 반환될 때마다 이 스택 프레임은 후입선출(last in first out) 순서로 증가하거나 감소하며, 이런 스택 프레임의 증감이 프로세스 주소 공간에서 스택 영역을 형성한다. 
- 스레드가 등장하며 하나의 프로세스에 실행 진입점(execution entry point)가 여럿 존재할 수 있게 되었고, 동시에 실행 흐름도 여러 개 존재할 수 있게 되었다. 실행 흐름이 하나뿐인 프로세스는 실행 시 정보를 저장하는 스택 영역이 하나만 있으면 되지만, 실행 흐름을 여러 개를 가지는 멀티 스레드 프로세스는 각 흐름이 실행될 때 정보를 저장하기 위해 스택 영역이 여러 개 필요하다. 프로세스의 주소 공간에 각 스레드를 위한 스택 영역이 별도로 있어야 한다. 즉, 모든 스레드는 각자 자신만의 스택 영역을 가지는데, 스레드가 이를 인지하고 있는 것이 중요하다. 스레드를 생성하면 프로세스의 메모리 공간이 소모된다는 점도 주의할 필요가 있다. 

---
* 함수의 스택 프레임: 함수가 호출될 때마다 스택에 할당되는 메모리 블록입니다. 이 프레임에는 함수의 매개변수, 지역 변수, 리턴 주소 등이 저장됩니다.
* 실행 시간 스택 프레임: 이 용어는 함수 호출 시 생성된 일련의 스택 프레임을 말합니다. 스레드는 자신의 실행 흐름을 유지하기 위해 여러 함수 호출을 거치며, 이때 스택 프레임들이 연속적으로 쌓이게 됩니다.
* 스레드와 스택 프레임의 연관성: 각 스레드는 자신만의 스택 영역을 가지고 있으며, 이 스택 영역에 각 함수 호출 시마다 스택 프레임이 쌓입니다. 스레드가 함수 호출을 할 때마다 스택에 새로운 프레임이 추가되고, 함수가 종료되면 해당 프레임이 제거됩니다. 이러한 과정을 통해 스레드는 자신의 실행 흐름을 추적하고, 독립적인 작업을 수행할 수 있습니다.
* 스레드가 독립적으로 작업을 수행하기 위해서는 자신만의 메모리 공간이 필요하며, 특히 함수 호출 및 지역 변수 저장을 위해 스택(Stack) 영역이 필수적입니다. 스택은 LIFO(Last In, First Out) 방식으로 작동하며, 함수 호출 시 함수의 매개변수, 리턴 주소, 지역 변수를 저장하고, 함수가 종료되면 이 정보를 스택에서 제거합니다.

스레드가 독립적인 스택 영역을 가져야 하는 가장 큰 이유는 스레드 간의 데이터 충돌을 방지하고 독립적인 실행 흐름을 유지하기 위해서입니다. 좀 더 구체적으로 설명하자면:

1. 지역 변수 충돌 방지

각 스레드는 함수 호출 시 지역 변수를 사용합니다. 이 지역 변수들은 해당 함수의 스택 프레임에 저장됩니다. 만약 스레드들이 스택 영역을 공유한다면, A 스레드의 함수가 사용하는 지역 변수가 B 스레드의 함수에 의해 덮어씌워질 수 있습니다. 이렇게 되면 데이터가 엉키게 되고, 예기치 않은 결과가 발생할 수 있습니다. 독립적인 스택 영역이 있으면, 각 스레드는 자신만의 지역 변수를 안전하게 관리할 수 있습니다.

2. 함수 호출 및 리턴 주소 관리

함수가 호출되면 현재 실행 위치를 저장하고 새로운 함수로 이동합니다. 이때 함수의 리턴 주소가 스택에 저장됩니다. 만약 스레드들이 스택을 공유한다면, 한 스레드가 다른 스레드의 리턴 주소를 덮어써버릴 수 있어, 함수 호출이 끝난 후 잘못된 위치로 돌아갈 위험이 있습니다. 독립적인 스택이 있으면, 각 스레드는 자신의 함수 호출과 리턴 주소를 안전하게 관리할 수 있습니다.

3. 스택 오염 방지

한 스레드가 스택에서 데이터를 기록하거나 삭제하는 동안, 다른 스레드가 같은 스택에 접근하면 데이터 오염이 발생할 수 있습니다. 이러한 오염은 프로그램의 비정상 종료나 잘못된 동작을 초래할 수 있습니다. 독립적인 스택은 이런 문제를 방지합니다.

4. 디버깅과 유지보수 용이

스레드가 독립적인 스택을 갖고 있으면, 각 스레드의 실행 상태를 개별적으로 추적하고 관리하기가 더 쉬워집니다. 이는 디버깅이나 성능 최적화 작업에서 큰 장점을 제공합니다.

결론적으로, 스레드가 독립적인 스택 영역을 가져야 하는 이유는 스레드 간의 데이터 간섭을 방지하고, 각 스레드가 독립적으로 안전하게 실행될 수 있도록 보장하기 위해서입니다. 이로 인해 멀티스레드 환경에서의 안정성, 예측 가능성, 그리고 성능이 보장됩니다.

----

### 스레드 활용 예
- 생명  주기(lifecycle) 관점에서 볼 때, 스레드가 처리해야 하는 작업에는 긴 작업(long task)와 짧은 작업(short task)가 있다. 
- 긴 작업: 프로세스의 생명 주기와 비슷하거나 동일한 작업들.
- 짧은 작업: 네트워크 요청, 데이터베이스 쿼리 등 처리 시간이 짧은 작업들 (서버) - 특징은 작업 처리에 필요한 시간이 짧고, 작업 수가 많다.
- 요청당 스레드(thread-per-request): 요청이 들어올 때마다 매번 스레드가 생성된다. 긴 작업 대상으로는 매우 잘 동작한다. 하지만 대량의 짧은 작업에서는 스레드 생성과 종료에 많은 시간을 허비하고, 스레드마다 각자 독립적인 스택 영역이 필요한데 많은 수의 스레드를 생성하면 메모리와 기타 시스템 리소스를 너무 많이 소비하게 되고, 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가하기 때문에 단점이 있다. 
- 따라서 요청이 들어올 때마다 스레드를 생성하는 대신, 요청이 들어올 때만 요청을 처리하고 없을 때는 휴식하는 것이 낫다. 이것이 thread pool (스레드 풀)이 탄생하게 된 이유이다.  

### 스레드 풀의 동작 방식
- 스레드 풀(thread pool): 스레드 여러 개를 미리 생성해두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리 요청을 한다. 스레드 여러 개가 미리 생성되어 있기 때문에 스레드 생성과 종료 작업이 빈번하게 발생하지 않으며, 스레드 풀 내에 있는 스레드 수도 일반적으로 일정하게 관리되기 때문에 불필요하게 많은 메모리를 소비하지 않는다. 여기서 중요한 점은 스레드를 재사용한다는 점이다.
- 작업을 스레드 풀 내에 있는 스레드에 전달하는 방법: 자료 구조(data structure)의 대기열(queue)를 통해 생산자(producer)가 작업을 처리하는 스레드인 소비자(consumer)에게 작업을 전달한다 (전형적인 생산자-소비자 패턴: producer-consumer pattern이다).
- 본질적으로 스레드 풀에 전달되는 작업은 1) 처리할 데이터, 와 2)데이터를 처리하는 함수 두 부분으로 구성된다 (작업이 처리할 데이터와 데이터 처리 함수). 이때 먼저 스레드 풀의 스레드는 작업 대기열(jobs queue)에서 블로킹 상태로 대기하고 있다가 생산자가 작업 대기열에 데이터를 기록하면 풀의 스레드가 깨어나고, 꺠어난 스레드는 작업 대기열에서 구조체를 가져온 후에 구조체의 handle이 가리키는 처리 함수(handler function)을 실행한다. 여기서 작업 대기열(task queue)는 여러 스레드 간에 공유되는 리소스이므로, 동기화를 할 때 상호배제(mutual exclusion in synchronization) 문제도 반드시 처리해야 한다. 

---
스레드 풀(Thread Pool)은 효율적인 멀티스레딩을 구현하기 위한 중요한 패턴입니다. 스레드 풀의 주요 목적은 스레드 생성과 종료의 오버헤드를 줄이고, 시스템 자원을 효율적으로 관리하는 것입니다. 스레드 풀은 다음과 같은 방식으로 동작합니다.

스레드 풀의 동작 방식

	1.	스레드 풀의 초기화:
	•	스레드 풀 생성: 애플리케이션이 시작될 때, 스레드 풀은 미리 여러 개의 스레드를 생성해둡니다. 이 스레드들은 idle 상태로 대기하며, 작업을 처리할 준비가 되어 있습니다.
	•	고정된 스레드 수: 일반적으로 스레드 풀 내의 스레드 수는 고정되어 있습니다. 이는 시스템 자원의 사용량을 제어하고, 불필요한 메모리 소비를 방지하기 위함입니다. 스레드 수는 시스템의 CPU 코어 수, 애플리케이션의 성능 요구 사항 등을 고려하여 결정됩니다.
	2.	작업 큐(작업 대기열)로 작업 전달:
	•	작업 요청: 작업이 발생하면, 해당 작업은 스레드 풀의 작업 큐(task queue)에 추가됩니다. 이 작업은 처리해야 할 데이터와 이를 처리하는 함수(작업 처리 함수)로 구성됩니다.
	•	작업 큐 관리: 작업 큐는 FIFO(First-In, First-Out) 방식으로 관리됩니다. 즉, 먼저 들어온 작업이 먼저 처리됩니다. 큐의 상태는 여러 스레드가 접근할 수 있기 때문에 동기화가 필요하며, 이를 통해 상호 배제(mutual exclusion) 문제가 처리됩니다.
	3.	스레드의 작업 처리:
	•	스레드 활성화: 대기 중인 스레드는 작업 큐에 작업이 들어오면, 그 작업을 가져와서 처리합니다. 스레드는 작업 큐에서 작업을 가져오자마자 idle 상태에서 깨어나 active 상태로 전환됩니다.
	•	작업 실행: 스레드는 작업 큐에서 꺼낸 작업을 처리합니다. 여기서 작업은 일반적으로 함수 포인터나 람다 표현식 등으로 전달된 처리 함수를 실행하는 것을 의미합니다.
	•	재사용: 작업이 완료되면, 스레드는 다시 idle 상태로 전환되어 다음 작업을 기다립니다. 스레드를 종료하지 않고 재사용하기 때문에, 스레드 생성 및 종료에 따른 오버헤드가 발생하지 않습니다.
	4.	동기화와 상호 배제:
	•	동기화 문제: 작업 큐는 여러 스레드가 동시에 접근할 수 있는 공유 리소스입니다. 따라서 작업 큐에 작업을 추가하거나, 작업을 꺼내올 때 동기화가 필요합니다. 이를 통해 데드락(deadlock)이나 경쟁 상태(race condition)를 방지합니다.
	•	락(lock) 사용: 일반적으로 뮤텍스(Mutex)나 세마포어(Semaphore) 같은 동기화 도구가 사용됩니다. 이러한 도구를 통해 하나의 스레드가 작업 큐를 안전하게 접근하도록 보장합니다.
	5.	작업 완료와 결과 처리:
	•	작업 완료: 스레드가 작업을 완료하면, 해당 작업의 결과는 필요에 따라 별도의 결과 큐나 콜백 함수로 전달될 수 있습니다.
	•	결과 수집: 결과는 주로 호출한 스레드나 별도의 결과 처리 스레드에서 수집되어, 필요한 후속 작업이 이루어질 수 있습니다.
	6.	스레드 풀 종료:
	•	정상 종료: 애플리케이션이 종료될 때, 스레드 풀은 모든 작업이 완료된 후에 안전하게 스레드를 종료합니다. 이는 일반적으로 모든 작업이 완료되거나, 명시적으로 풀을 종료하는 요청이 들어왔을 때 이루어집니다.

스레드 풀의 장점

	•	성능 향상: 스레드 풀을 사용하면 스레드 생성과 종료에 따르는 오버헤드를 줄일 수 있어, 응답 시간이 빨라지고 시스템 자원을 효율적으로 사용할 수 있습니다.
	•	자원 관리: 스레드 수를 제어할 수 있으므로, 불필요하게 많은 메모리와 CPU를 소비하지 않습니다.
	•	확장성: 스레드 풀은 여러 작업을 병렬로 처리할 수 있기 때문에, 특히 서버 애플리케이션이나 고성능 요구사항이 있는 프로그램에서 유리합니다.

스레드 풀의 한계 및 고려사항

	•	복잡한 동기화: 스레드 풀의 동작 과정에서 동기화 문제를 제대로 처리하지 않으면, 데드락이나 경쟁 상태와 같은 문제가 발생할 수 있습니다.
	•	작업 큐 오버플로우: 작업이 너무 빠르게 들어오면 큐가 가득 차서 새로운 작업을 처리할 수 없게 될 수 있습니다. 이 경우 적절한 백프레셔(Backpressure) 전략이 필요합니다.
	•	리소스 고갈: 너무 많은 스레드를 사용하는 경우, 시스템 자원이 고갈되어 성능 저하가 발생할 수 있습니다.

결론스레드 풀은 다수의 작업을 효율적으로 처리하기 위한 중요한 기법으로, 미리 생성된 스레드가 작업을 대기하며, 작업 큐를 통해 전달된 작업을 처리하고 재사용되는 구조입니다. 이 과정에서 동기화와 자원 관리가 중요한 역할을 하며, 이를 통해 시스템의 성능을 최적화할 수 있습니다.

---

### 스레드 풀의 스레드 수
스레드 풀에 스레드가 너무 적다면 CPU를 최대한 활용할 수 없고, 반대로 너무 많다면 시스템의 성능 저하, 메모리의 과다한 점유, 스레드 전환으로 생기는 부담 등 문제가 발생한다. 그렇다면 몇 개가 적당한지 어떻게 결정할까?

스레드 풀에서 처리할 작업의 종류에 따라서 달라진다.

작업을 처리할 때 필요한 리소스 관점에서 바라보고 작업을 구분하자면, CPU 집약적인 작업(CPU intenstive task)와 입출력 집약적인 작업(input/output intensive task)으로 구분할 수 있다.

- CPU 집약적인 작업: 과학 연산, 행렬 연산 등 작업을 처리할 때 외부 입출력에 의지할 필요없이 처리할 수 있는 작업을 의미한다. 이 경우 스레드 수와 CPU의 코어 수가 기본적으로 동일하다면 CPU의 리소스를 충분히 활용할 수 있다.
- 입출력 집약적인 작업: 연산 부분이 차지하는 시간은 많지 않은 대신 대부분의 시간을 디스크 입출력이나 네트워크 입출력 등에 소비하는 작업을 의미한다. 보통 성능 테스트 도구를 사용해서 WT(Wait Time)이라는 입출력 대기 시간과 CT(Computing Time)이라는 CPU 연산에 필요한 시간을 평가해야 한다. N개의 코어를 가진 시스템에서 적절한 스레드 수는 대략 N X (1+WT % CT)이며, WT와 CT가 동일하다고 가정하면 대략 2N개의 스레드가 있어야 CPU 리소스를 최대한 활용할 수 있다.

하지만 이는 이론적인 값에 불과하고 스레드 수를 결정하는 절대 공식은 없으며, 이를 위해서는 구체적인 상황과 그에 대한 분석이 필요하다. 