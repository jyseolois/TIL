# 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
메모리 내 프로세스 구조는 다음과 같다:
커널
스택 영역(함수 실행 시 정보 저장)
힙 영역(동적 메모리 할당)
데이터 영역
코드 영역
메모리의 모든 프로세스는 이런 모습을 하고 있다. 모든 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 코드 영역(code segment)와 데이터 영역(data segment)은 실행 파일을 초기화할 때 생성되는 영역이다. (코드 영역 - 앱 실행 시 로드된 프로그램 명령어 저장. 데이터 영역-  프로그램 실행 중 필요한 전역 변수와 정적 변수를 저장. 클래스 로딩 시 object 키워드나 companion object로 선언된 변수들이 이 영역에 저장)
- 힙 영역(heap segment)은 동적 메모리 할당에 사용되는데, 구체적으로 C/C++ 언어의 malloc 함수에서 요청한 메모리가 이 힙 영역에 할당된다. (앱이 실행 중에 필요에 따라 생성하는 객체와 데이터를 저장하는 데 사용. 즉, 안드로이드 앱에서 동적으로 생성되는 객체들은 모두 힙 영역에 저장. 예를 들어 User 클래스나 List 객체는 실행 중에 동적으로 생성되므로 힙에 할당)
- 스택 영역(stack segment)은 함수 호출에 사용되며 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장하는 데 사용된다. (함수 실행 시 생성되는 지역 변수와 함수 호출 정보가 이곳에 저장)
- => 코드 영역은 코드의 로직 그 자체(방법)을 저장하고, 실행 중 생성되고 변화하는 데이터는 다른 메모리 영역(데이터, 힙, 스택)에 나뉘어 관리

## 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다
프로세스 주소 공간 구조에서 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 malloc 함수를 호출하면 둘 다 0x7f64cb8을 반환하는 등 동일한 시작 주소를 반환할 가능성이 매우 높다. 그렇다면 이 두 프로세스가 모두 주소 0x7f64cb8에 데이터를 쓸 수 있다는 건데 이것이 문제되지는 않을까? 문제되지 않는다. 왜냐면 0x7f64cb8라는 메모리 주소는 가짜 주소이며, 이 주소는 메모리에 조작이 이렁나기 전에 실제 물리 메모리 주소에 변경된다. 다시 말해 코드, 데이터, 힙, 스택 같은 구조는 가상적인 구조에 불과하고, 실제 메모리에는 애초에 이런 형태의 구조가 존재할 수 없다. 오히려 실제 물리 메모리의 모습은 각 프로세스의 영역이 조각으로 나뉘어져 중구난방으로 흩어져 있는 모습에 훨씬 가깝다. 즉, 실제 물리 메모리에서는 프로세스는 동일한 크기의 조각(chunck)로 나뉘어 물리 메모리에 저장된다 (ex. 프로세스의 힙 영역이 동일한 크기의 조각 x개로 나뉘어져 있다 - 힙 영역 파트1, 힙 영역 파트 2…), 그리고 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다. 이런 물리 메모리와 가상 메모리 사이에는 사상(mapping) 관계가 있고, 페이지 테이블(page table)이 존재한다.

## 페이지와 페이지 테이블: 가상에서 현실로
가상 메모리 주소 공간은 물리 메모리에 매핑되어 있다. 가상 메모리 주소와 물리 메모리 주소의 매핑 관계가 유지되는 한, 프로세스 주소 공간의 데이터가 실제 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다. 이런 사상 관계(maaping)을 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 한다. 여기서 주목할 만한 것은 모든 가상 주소를 물리 주소에 사상하는 대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 페이지(page)라고 부른다는 점이다. 이처럼 사상은 페이지 단위로 이루어지므로, 페이지 테이블이 가져야 하는 항목 수가 대폭 줄어든다. 이제 두 프로세스가 동일한 메모리 주소에 기록하더라도 문제가 발생하지 않는 이유를 알 수 있다. 이 메모리 주소가 가르키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문이다. (Ex. 프로세스 A 코드 영역 Part 2, 프로세스 B 코드 영역 Part 2). 따라서 표준적이고 깔끔하게 정리된 가상 주소 공간은 현실에는 존재하지 않으며, 단지 논리적인 표현에 불과하다. 이것이 바로 최신 운영 체제에서 매우 중요한 기능인 가상 메모리의 기본 구현 원리이다. 