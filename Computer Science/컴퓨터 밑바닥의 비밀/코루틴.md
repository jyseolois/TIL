# 코루틴(coroutine)

## 일반 함수
- 일반 함수는 return 명령어를 만나거나 코드의 마지막 줄까지 실행되어야 반환이 가능하다. 또 해당 함수가 재호출되면, 다시 처음부터 시작하여 반환될 때까지 모든 줄을 하나씩 실행한다.
  
## 일반 함수에서 코루틴으로
- 코루틴에는 스레드와 유사한 기능인 일시 중지와 재개 기능이 있다.
- 코루틴은 자신의 실행 상태를 저장할 수 있기 때문에, 코루틴이 반환된 후에도 계속 호출이 가능하며, 마지막으로 일시 중지된 지점에서 다시 이어서 실행된다. 호출한 쪽에서 코루틴을 호출할 때마다 해당 코루틴은 이전에 반환되었던 지점부터 다시 계속 실행될 수 있는 것이다.
- 일반 함수는 반환된 후에 프로세스 주소 공간의 스택 영역에 함수 실행 시 정보를 저장하지 않지만, 코루틴이 반환될 때는 함수의 실행 시 정보를 저장할 필요가 있는데, 코루틴이 실행이 멈추었던 지점에서 다시 실행할 때 이 정보가 필요하기 때문이다. 이처럼 코루틴은 자신의 이전 실행 상태를 기억하고 있다가, 다시 실행될 때 이전에 일시 중지되었던 지점에서 계속 실행이 가능한 매우 신기한 함수이다.

## 직관적인 코루틴 설명
- 한 함수가 코루틴을 실행해서 코루틴이 시작되면 첫 번째 연결 시작 지점까지 실행하다가, 다시 호출한 함수로 돌아간다. 함수는 이어서 실행되다가 다시 해당 코루틴을 실행한다. 그럼 코루틴은 첫 번째 줄의 코드부터 실행되는 것이 아니라, 앞의 연결 시작 지점부터 실행된다. 다시금 두 번째 연결 시작 지점을 만나고, 이번에도 호출한 함수로 돌아간다. 마지막으로 함수의 나머지 부분이 실행되고 전체 프로그램이 종료된다.

## 함수는 그저 코루틴의 특별한 예에 불과하다
- 코루틴이 일반 함수와 다른 점은 자신이 이전에 마지막으로 실행된 위치를 알 수 있는 것이다. 즉, 코루틴은 자신이 일시 중지될 때 실행 중인 상태를 저장했다가, 저장되었던 상태에서 다시 시작해서 계속 실행된다.
- 이는 운영 체제가 스레드를 스케줄링하는 것과 똑같다. 스레드도 일시 중지될 수 있으며, 운영체제가 먼저 스레드의 실행 상태를 저장했다가 다른 스레드의 스케줄링을 진행한다. 그리고 일시 중지된 스레드가 다시 CPU의 리소스를 할당받으면, 스레드는 마치 일시 중지된 적 없는 것처럼 이어서 실행한다. 
- 컴퓨터 시스템은 주기적으로 타이머 인터럽트(timer interrupt)를 생성하고, 인터럽트가 처리될 때마다 운영체제는 현재 스레드의 일시 중지 여부를 결정할 기회를 가진다. 그래서 프로그래머가 명시적으로 스레드를 언제 일시 중지시키고 CPU의 리소스를 내어 줄지 지정할 필요가 없다. 하지만 사용자 상태(user mode)에서는 타이머 인터럽트를 위한 작동 방식이 없기 때문에, 코루틴에서는 예약어를 사용해서 어디에서 일시 중지하고 CPU의 리소스를 내어 줄 것인지 명시적으로 지정해야 한다. 
- 코루틴 몇 개를 생성하든 상관없이 운영 체제는 이를 알지 못한다. 코루틴은 온전히 사용자 상태 내에서 구현된 것이기 때문에, 코루틴을 사용자 상태 스레드로 해석할 수 있다. 
- 코루틴을 통해 프로그래머는 운영 체제와 유사한 역할을 할 수 있다. 직접 코루틴이 언제 실행되고 일시 중지되는지를 제어할 수 있다. 즉, 코루틴의 스케줄링 제어권이 프로그래머에게 있다. 
- 함수는 코루틴의 단지 특별한 예에 불과하며, 실제로는 연결 시작 지점이 존재하지 않는 코루틴에 불과하다.

## 코루틴의 역사
- 스레드가 없던 시절 동시성을 가지는 프로그램을 작성하기 위해 코루틴이 탄생했지만, 이 스레드가 등장하고 운영 체제가 기본적으로 프로그램의 동시 실행을 지원하기 시작하면서 코루틴은 기억 속으로 사라져 갔다.
- 모바일 인터넷 시대가 되면서 서버에서 처리해야 하는 사용자 요청이 기하급수적으로 늘어나고, 코루틴은 높은 성능과 동시성을 요구하는 분야에서 다시 한번 중요해졌다. 

## 코루틴의 구현 방법
- 스레드의 구현과 본질적으로 차이가 없다.
- 코루틴은 일시 중지되거나 다시 시작할 수 있으며, 일시 중지 될 때의 상태 정보를 반드시 기록해야 하고, 이를 기반으로 코루틴을 다시 시작한다.
- 일반 함수의 상태 정보에는 1) CPU의 레지스터 정보, 2) 함수 실행 시 상태 정보가 포함되며, 함수의 상태 정보는 주로 함수의 스택 프레임에 저장된다. 프로세스의 주소 공간의 스택 영역은 스레드를 위한 공간이다.
- 코루틴의 실행 시간 스택 프레임 정보는 힙 영역에 저장된다. 이와 같은 이유로 수시로 코루틴을 일시중지하거나 재게할 수 있는 것이다. 
- 예를 들어서 한 프로그램에 일반 스레드가 한 개 있고, 코루틴이 두 개 있다면, 실행 흐름이 세 개 존재하는 것이다. 실행 흐름이 세 개가 존재하여도 스레드는 단 하나만 생성한 것이다. 메모리 공간이 충분하다면 코루틴 개수에 제한은 없으며, 코루틴 간 전환이나 스케줄링은 전적으로 사용자 상태에서 일어나기 때문에, 운영 체제가 개입할 필요가 없다. 또한 코루틴 간에 전환할 때 저장 또는 복구되는 정보도 더 가볍기 때문에 효율성도 훨씬 높다. 
- 코루틴의 중요한 역할 중 하나는 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 한다는 것이다.