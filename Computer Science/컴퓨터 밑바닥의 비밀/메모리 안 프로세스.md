# 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
메모리 내 프로세스 구조는 다음과 같다:
커널
스택 영역(함수 실행 시 정보 저장)
힙 영역(동적 메모리 할당)
데이터 영역
코드 영역
메모리의 모든 프로세스는 이런 모습을 하고 있다. 모든 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 코드 영역(code segment)와 데이터 영역(data segment)은 실행 파일을 초기화할 때 생성되는 영역이다. (코드 영역 - 앱 실행 시 로드된 프로그램 명령어 저장. 데이터 영역-  프로그램 실행 중 필요한 전역 변수와 정적 변수를 저장. 클래스 로딩 시 object 키워드나 companion object로 선언된 변수들이 이 영역에 저장)
- 힙 영역(heap segment)은 동적 메모리 할당에 사용되는데, 구체적으로 C/C++ 언어의 malloc 함수에서 요청한 메모리가 이 힙 영역에 할당된다. (앱이 실행 중에 필요에 따라 생성하는 객체와 데이터를 저장하는 데 사용. 즉, 안드로이드 앱에서 동적으로 생성되는 객체들은 모두 힙 영역에 저장. 예를 들어 User 클래스나 List 객체는 실행 중에 동적으로 생성되므로 힙에 할당)
- 스택 영역(stack segment)은 함수 호출에 사용되며 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장하는 데 사용된다. (함수 실행 시 생성되는 지역 변수와 함수 호출 정보가 이곳에 저장)
- => 코드 영역은 코드의 로직 그 자체(방법)을 저장하고, 실행 중 생성되고 변화하는 데이터는 다른 메모리 영역(데이터, 힙, 스택)에 나뉘어 관리

## 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다
프로세스 주소 공간 구조에서 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 malloc 함수를 호출하면 둘 다 0x7f64cb8을 반환하는 등 동일한 시작 주소를 반환할 가능성이 매우 높다. 그렇다면 이 두 프로세스가 모두 주소 0x7f64cb8에 데이터를 쓸 수 있다는 건데 이것이 문제되지는 않을까? 문제되지 않는다. 왜냐면 0x7f64cb8라는 메모리 주소는 가짜 주소이며, 이 주소는 메모리에 조작이 이렁나기 전에 실제 물리 메모리 주소에 변경된다. 다시 말해 코드, 데이터, 힙, 스택 같은 구조는 가상적인 구조에 불과하고, 실제 메모리에는 애초에 이런 형태의 구조가 존재할 수 없다. 오히려 실제 물리 메모리의 모습은 각 프로세스의 영역이 조각으로 나뉘어져 중구난방으로 흩어져 있는 모습에 훨씬 가깝다. 즉, 실제 물리 메모리에서는 프로세스는 동일한 크기의 조각(chunck)로 나뉘어 물리 메모리에 저장된다 (ex. 프로세스의 힙 영역이 동일한 크기의 조각 x개로 나뉘어져 있다 - 힙 영역 파트1, 힙 영역 파트 2…), 그리고 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다. 이런 물리 메모리와 가상 메모리 사이에는 사상(mapping) 관계가 있고, 페이지 테이블(page table)이 존재한다.

## 페이지와 페이지 테이블: 가상에서 현실로
가상 메모리 주소 공간은 물리 메모리에 매핑되어 있다. 가상 메모리 주소와 물리 메모리 주소의 매핑 관계가 유지되는 한, 프로세스 주소 공간의 데이터가 실제 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다. 이런 사상 관계(maaping)을 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 한다. 여기서 주목할 만한 것은 모든 가상 주소를 물리 주소에 사상하는 대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 페이지(page)라고 부른다는 점이다. 이처럼 사상은 페이지 단위로 이루어지므로, 페이지 테이블이 가져야 하는 항목 수가 대폭 줄어든다. 이제 두 프로세스가 동일한 메모리 주소에 기록하더라도 문제가 발생하지 않는 이유를 알 수 있다. 이 메모리 주소가 가르키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문이다. (Ex. 프로세스 A 코드 영역 Part 2, 프로세스 B 코드 영역 Part 2). 따라서 표준적이고 깔끔하게 정리된 가상 주소 공간은 현실에는 존재하지 않으며, 단지 논리적인 표현에 불과하다. 이것이 바로 최신 운영 체제에서 매우 중요한 기능인 가상 메모리의 기본 구현 원리이다.

# 스택 영역: 함수 호출은 어떻게 구현될까?
함수 실행 시간 스택(runtime stack) 또는 함수 호출 스택(call stack)을 먼저 이해해 보자.

### 프로그래머를 위한 도우미: 함수
동일한 기능을 하는 코드는 매번 반복해서 작성할 필요가 없도록 함수에 담아 둘 수 있다. 함수는 가장 기초적이고 간단한 코드 재사용 방식이다. 또한 함수는 프로그래머가 구현의 세부 사항을 감출 수 있게 하므로, 함수를 호출할 때는 함수 이름, 매개변수, 반환값만 알면 된다. 함수가 어떻게 구현되어 있는지는 전혀 신경 쓸 필요가 없으며, 이 역시 일종의 추상화에 해당한다. 그렇다면 함수의 호출은 어떻게 구현된 것일까?

### 함수 호출 활동 추적하기: 스택
스택 상단의 작업 궤적은 후입선출(last in first out)의 순서로, 본질적으로 스택과 같은 데이터 구조가 처리하기에 적합하다. 또한 사실상 이진 트리(binary tree)의 탐색(search)이라는 것도 알 수 있다. 이것이 리너 트리 구조의 순회가 재귀 구현 뿐만 아니라 스택 구현에도 사용될 수 있는 이유이다.

### 스택 프레임 및 스택 영역: 거시적 관점
모든 함수는 실행 시에 자신만의 작은 상자가 필요하다. 이 상자 안에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 이 상자들은 스택 구조를 통해 구성된다. 여기에서 각각의 작은 상자를 스택 프레임(stack frame)또는 호출 스택(call stack)이라고 한다. 그리고 이 구조는 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다. 프로세스 스택 영역의 높은 주소(highest address)가 맨 위에 있고, 스택 영역은 낮은 주소 방향으로 커진다. 다시 말해, 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고, 함수 호출이 완료될수록 감소한다. 그렇다면 스택 프레임이라는 이 작은 상자 안에는 무엇이 들어 있을까? 이 질문에 답하려면 함수를 호출할 때 어떤 정보들이 포함되는지 이해해야 한다. 

### 함수 점프와 반환은 어떻게 구현될까?
함수 A가 함수 B를 호출하면 제어권이 함수 A에서 함수 B로 옮겨지고, 여기에서 제어권은 실제로 CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지를 의미한다. CPU가 함수 A의 명령어를 실행하다가 함수 B의 명령어로 점프하는 것을 제어권이 함수 A에서 함수 B로 이전되었다고 이야기한다. 제어권이 이전될 때는 다음 두 가지 정보가 필요하다: 반환(return) 즉, 어디에서 왔는지에 대한 정보. 그리고 점프(jump) 즉, 어디로 가는지에 대한 정보. 다시 말해, 함수 A가 함수 B를 호출할 때 함수 A의 기계 명령어가 어디까지 실행되었는지(어디에서 왔는지), 그리고 함수 B의 첫 번째 기계 명령어가 위치한 주소(어디로 가는지)를 알아야 한다. 이 두 가지 정보만 있으면, CPU에 함수 A에서 함수 B로 점프하여 명령어를 실행하게 한 후, 함수 B의 실행이 완료되면 다시 함수 A로 점프하게 할 수 있다. 바로 이런 정보가 스택 프레임에 담기는 것이다. 예를 들어 함수 A가 함수 B를 호출할 때 CPU가 함수 A의 기계 명령어를 실행하고 있다가 call 0x400540 같은 기계 명령어를 만나면 이에 대응하는 것은 코드의 함수 호출이므로 함수 B의 첫 번째 기계 명령어 주소인 함수 B의 0x400540로 CPU는 점프하게 된다. 또한 call 명령어 다음에 위치한 주소를 함수 A의 스택 프레임에 넣는다. 이것이 바로 함수 A의 반환주소이다. 즉, CPU는 함수 B의 대응하는 기계 명령어를 실행하기 시작하면 함수 B를 위한 새로운 스택 프레임이 추가되고 스택 영역이 차지하는 메모리 크기도 증가하는데, 함수 B의 마지막 기계 명령어인 ret까지 계속 실행한 다음 이 기계 명령어에 따라 CPU에 함수 A의 스택 프레임에 저장된 반환 주소로 점프한다. 이에 따라 함수 B의 실행이 완료되면, 바로 함수 A로 점프하여 계속 실행할 수 있다. 함수 A의 스택 프레임에 저장된 주소는 0x40056a이며, 이는 함수 A의 call 명령어 바로 다음 기계 명령어의 주소에 해당한다. 함수의 반환 주소 외에 또 어떤 정보가 스택 프레임에 저장될까?

### 매개변수 전달과 반환값은 어떻게 구현될까?
CPU는 기계 명령어를 실행할 때 점프와 반환이 가능하기 때문에 이를 이용해서 함수를 호출할 수 있었다. 하지만 함수를 호출할 때는 함수 이름 외에도 매개변수를 전달하고 반환값을 가져와야 한다. 이를 어떻게 구현할 수 있을까? X86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다. 함수 A가 함수 B를 호출한다면, 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다. 마찬가지로 함수 B도 반환값을 레지스터에 저장하고, 함수 B의 실행이 완료되면 이 레지스터에서 반환값을 가져올 수 있다. 