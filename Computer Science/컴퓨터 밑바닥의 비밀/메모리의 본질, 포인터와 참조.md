# 메모리의 본질, 포인터와 참조
CPU는 메모리의 도움 없이는 동작이 불가능하다. 이것은 사람의 뇌가 기억, 저장, 연산을 모두 담당하는 것과는 조금 다르다. 컴퓨터 시스템에서 연산을 담당하는 것은 CPU이고, 저장을 담당하는 것은 메모리이다.

메모리는 개념적으로 매우 단순해서 0과 1을 저장할 수 있는 사물함에 불과하다. 그러나 인류는 이 단순한 사물함에 힙 영역(heap segment), 스택 영역(stack segment), 데이터 영역(data segment), 가상 메모리(virtual memory), 메모리 할당(memory allocation), 메모리 해제(memory free), 메모리 누수(memory leak)과 같은 개념을 만들어냈다. 어떤 프로그래밍 언어로 프로그램을 작성하든지 모든 프로그램은 메모리에서 실행되어야 한다. 

## 메모리의 본질: 사물함, 비트, 바이트, 객체
메모리에서 파생된 개념: 바이트(byte), 구조체(structure), 객체(object), 변수(variable), 포인터(pointer), 참조(reference)

- 메모리는 사물함에 비유할 수 있다. 대신 메모리는 사물함 대신 메모리 셀(memory cell)이라는 표현을 사용한다.
- 비트: 메모리 셀에는 오직 0과 1만 보관할 수 있으며, 0 또는 1을 1비트(bit)라고 한다. 따라서 1비트는 0 또는 1이다. 1비트는 예 또는 아니요, 참(ture) 또는 거짓(false) 같은 대비되는 두 가지 정보만 표현할 수 있다.
- 바이트: 더 많은 정보를 표현하기 위해 비트 여덞 개를 묶어서 정보를 나타내는 하나의 단위인 1바이트(byte)를 사용한다. 따라서 모든 바이트는 메모리 내 자신의 주소를 가지고 있으며, 우리는 이 주소를 일반적으로 메모리 주소(memory address)라고 한다. 메모리 주소 한 개를 사용해서 특정한 사물함 여러 개를 찾을 수 있으며, 이를 주소 지정(addressing)이라고 한다. 하지만 1바이트 역시 8비트이기 때문에 정보를 표현하는 능력에는 한계가 있다. 8비트로 만들 수 있는 조합은 2^8인 256개에 불과하므로, 이를 부호 없는 정수(unsigned integer)로 표현하면 0부터 255까지 숫자만 표현 가능하다.
- 4바이트: 하지만 우리는 많은 것을 표현하기 위해 훨씬 큰 숫자가 필요하고, 일반적으로 4바이트를 묶어 하나의 정수를 표현하는 단위로 사용한다. 4바이트는 32비트로써 2^32개, 즉 4,294,967,296 개의 조합이 가능하기 때문에, 우리가 숫자를 표현하고자 할 때 충분히 대응할 수 있다. 이것이 C 언어와 같은 프로그래밍에서 int 형 변수의 크기가 4바이트인 이유이다.
- 구조체, 객체: 그러나 정수를 표현하는 것 외에도 정보 조합을 표현하고 싶을 수 있다. 여기서 각 항목은 정수에 해당하지만 동시에 이들은 모두 하나의 객체, 예를 들어 태진 정보에 해당한다. 이제 4바이트 메모리로는 충분하지 않으며, 서로 다른 정보 세 개를 표현하려면 12바이트가 필요하다. 이 12바이트를 사용해서 정보를 조합해서 표시하는 것을 프로그래밍 언어에서는 구조체(structure) 또는 객체(object)라고 표현한다.
- 컴퓨터는 0과 1만 이해할 수 있다: 프로그래밍 언어에서 사용되는 개념이 간단하든 복잡하든 상관없이 사물함에 저장되는 것은 0 또는 1이며, 모든 개념은 해석하기 나름이다. 8비트를 1바이트로 생각할 수 있고, 4바이트를 정수로 생각할 수 있으며, 연속된 메모리를 이용해서 구조체나 객체를 저장할 수도 있다. 하지만 메모리는 이것에 전혀 관심이 없으며, 메모리 안에 저장된 것은 어찌 되었든 모두 0 또는 1 뿐이다. 메모리 내 사물함에는 0 또는 1만 저장할 수 있으며, 따라서 컴퓨터는 0과 1만 이해할 수 있다. 

## 메모리에서 변수로: 변수의 의미
- 메모리 읽기와 쓰기의 본질: 본질은 메모리는 사물함이라는 사실을 인지하고 있어야 한다. 1바이트를 저장할 수 있는 사물함 여러 개가 하나로 묶여 있고, 각각 하나씩 번호가 붙어있는데, 이 번호가 바로 메모리 주소이다.
- 만약 1 + 2 값을 계산하고 싶다면, 먼저 숫자 1 과 숫자 2를 메모리에 저장해야 한다. CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 수행할 수 있기 때문이다. 
- 숫자 1과 숫자 2를 표현하기 위해 각각 1바이트를 사용한다고 가정하면, 먼저 이 두 숫자를 각각 사물함 두 개에 넣어야 한다. 그 중 숫자 1를 사물함 중 6번 사물함에 넣는다고 가정하자. 메모리에 정보를 저장할 때 store 명령어를 사용한다면, 숫자 1를 메모리에 저장하는 것은 다음과 같이 표현할 수 있다 :
```
Store $1 6
```
이 명령어에서 1과 6이라는 숫자 두 개를 볼 수 있는데, 모두 숫자라는 형식으로 되어 있지만 그 안의 의미는 서로 다르다. 하나는 저장할 숫자 값(data value)를 의미하고, 하나는 사물함 번호, 즉 메모리 주소를 의미한다. 쓰기에 대응하는 읽기를 위해 load 명령어를 사용한다고 가정하면, 그 형태는 다음과 같다.
-
```
load r1 6
```
$ 기호가 붙어 있으면 값이고 없다면 메모리 주소를 의미한다 - 값과 메모리 주소를 구분하기 위함이다.
이제 주소 6은 숫자 1을 나타낸다.
```
주소6 -> 숫자1
```
-
- 변수: 하지만 주소 6이라는 표현은 인간에게 익숙하지 않다. 따라서 주소 6에 a라는 별칭을 붙이면, a가 주소 6을 나타내게 되며, a에 저장된 값이 바로 1이 된다. 이것이 바로 변수다. 사람들은 이 정보를 다음과 같이 대수학을 이용한 직관적인 표현을 사용한다.
-
```
a = 1
```
표면상으로는 a 변수가 값 1과 동일한 것으로 보이지만, 그 뒤에 매우 중요한 정보를 감추고 있다는 것을 알 수 있다. 그 정보는 바로 a 변수가 숫자 1이 메모리 주소 6에 저장되어 있다는 것이다. 다시 말해 a 변수 또는 별칭 a의 뒤에는 다음과 같은 두 의미가 있다: 1) 값 1을 나타낸다. 2) 이 값은 메모리 주소 6에 저장된다.
-
```
b = a
```
a 값을 b에 준다는 이 할당을 메모리 관점에서 바라보면 어떤 의미를 지닐까? b 변수를 위해 사물함을 하나 할당해서 2번 사물함에 b변수를 저장했다고 가정하면, a 변수의 숫자 데이터를 완전히 복제 해서 2번 사물함에 넣을 수도 있다. 

- 구조체와 데이터: 만약 a 변수가 1바이트의 데이터뿐만 아니라, 구조체나 객체처럼 여러 바이트를 차지하는 데이터도 나타낼 수 있다고 가정하면, 이제 a 변수는 5바이트를 차지하며, 만약 이것이 메모리의 절반 이상에 해당하고, 이런 상황에서도 여전히 b = a를 표현해야 한다면 어떻게 해야 할까? 만약 이전처럼 데이터를 복사하는 방법을 사용하게 되면 메모리 공간이 부족하게 된다. 