# 추상화
- CPU: CPU 하드웨어는 트랜지스터 여러 개로 구성되어 있지만, 명령어 집합(instruction set)이라는 개념으로 내부 구현 세부 사항을 보호하고, 프로그래머는 덕분에 트랜지스터의 세부 사항은 전혀 고려할 필요 없이 명령어 집합에 ㅁ포함된 기계 명령어를 사용해 CPU에 작업을 지시하기만 하면 된다. 그리고 기계 명령어에 대한 추상화 계층(abstract layer)은 고급 프로그래밍 언어로 다시 이어지고, 프로그래머는 덕분에 기계 명령어의 세부 사항에 신경 쓸 필요 없이 고급 언어를 이용해서 CPU를 쉽게 제어하여 프로그래밍의 효율성이 높아진다. 
- 입출력(input/output) 장치: 파일(file)로 추상화돼 있다. 따라서 파일을 사용할 때 파일 내용이 정확히 어떻게 저장되는지(어느 트랙tract의 어느 섹터sector에 정확히 저장되는 지 등) 등 세부 사항은 전혀 신경필요가 없다. 
- 실행 중인 프로그램: 프로세스로 추상화된다. 프로그래머는 프로그램을 작성할 때 자신의 프로그램이 CPU를 독전함다고 가정할 수 있기 때문에 단일 CPU 시스템에서도 수많은 프로세스가 동시에 실행될 수 있다.
- 물리 메모리와 파일: 가상 메모리로 추상화된다. 프로그래머는 물리 메모리의 크기가 서로 다른 경우에도 자신의 프로그램이 표준적이고 동일한 크기의 메모리에 독점적으로 접근할 수 있다고 가정할 수 있다. 또, mmap 작동 방식을 이용해서 가상 메모리를 사용하더라도 실제 메모리를 읽고 쓰는 것처럼 쉽게 파일을 조작할 수 있다.
- 네트워크 프로그래밍(network programming): 소켓(socket)으로 추상화된다. 프로그래머는 네트워크 패킷(packet)이 계층별로 어떻게 해석되는지, 네트워크 카드가 어떻게 데이터를 송수신하는지 전혀 신경 쓸 필요가 없다.
- 프로세스와 프로세스에 종속적인 실행 환경: 컨테이너(container)로 추상화된다. 프로그래머는 더 이상 개발 환경과 실제 배포 환경의 차이를 걱정하지 않아도 된다.
- CPU, 운영체제, 응용 프로그램(application)은 가상 머신으로 묶여(packaging) 추상화된다. 프로그래머는 더 이상 예전처럼 여러 가지 하드 웨어를 직접 구입하여 직접 운영 체제를 설치하고 프로그램을 구성하고 서버 환경을 운영할 필요가 없어졌다. 가상 머신은 일종의 데이터로서 빠르게 복제가 가능하기 때문에, 프로그래머는 이제 한 손으로 수많은 서버를 운영하고 유지하고 관리할 수 있다.
- 추상화는 프로그래머를 저수준 계층에서 점점 멀어지게 만들고, 점점 더 저수준 계층의 세부 사항도 신경 쓸 필요가 없도록 만든다. 

# Chapter 1 요약
- 프로그래머가 작성한 코드는 실제로 문자열 나열에 지나지 않으며, 텍스트 파일에서 볼 수 있는 단락과 다르지 않다. 단지 코드는 프로그래밍 언어의 문법을 따른다.
- 하지만 CPU는 if else 같은 문법을 전혀 이해할 수 없으며, 기계 명령어만 실행할 수 있다.
- 이때 컴파일러는 번역기 역할을 하여 프로그래밍 언어 문법에 따라 코드를 구문 분석하고, 최종적으로 기계 명령어를 생성한다.
- 컴파일러는 CPU를 세부 사항에서 보호해서 프로그래머가 기계 명령어를 전혀 알지 못해도 프로그래밍이 가능하게 해 주는데, 이것이 바로 추상화의 힘이다.
- 링커는 모든 코드와 데이터, 라이브러리를 한 데 묶어 실행 파일을 생성하는 역할을 한다.