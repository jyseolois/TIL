# 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
메모리 내 프로세스 구조는 다음과 같다:
커널
스택 영역(함수 실행 시 정보 저장)
힙 영역(동적 메모리 할당)
데이터 영역
코드 영역
메모리의 모든 프로세스는 이런 모습을 하고 있다. 모든 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 코드 영역(code segment)와 데이터 영역(data segment)은 실행 파일을 초기화할 때 생성되는 영역이다. (코드 영역 - 앱 실행 시 로드된 프로그램 명령어 저장. 데이터 영역-  프로그램 실행 중 필요한 전역 변수와 정적 변수를 저장. 클래스 로딩 시 object 키워드나 companion object로 선언된 변수들이 이 영역에 저장)
- 힙 영역(heap segment)은 동적 메모리 할당에 사용되는데, 구체적으로 C/C++ 언어의 malloc 함수에서 요청한 메모리가 이 힙 영역에 할당된다. (앱이 실행 중에 필요에 따라 생성하는 객체와 데이터를 저장하는 데 사용. 즉, 안드로이드 앱에서 동적으로 생성되는 객체들은 모두 힙 영역에 저장. 예를 들어 User 클래스나 List 객체는 실행 중에 동적으로 생성되므로 힙에 할당)
- 스택 영역(stack segment)은 함수 호출에 사용되며 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장하는 데 사용된다. (함수 실행 시 생성되는 지역 변수와 함수 호출 정보가 이곳에 저장)
- => 코드 영역은 코드의 로직 그 자체(방법)을 저장하고, 실행 중 생성되고 변화하는 데이터는 다른 메모리 영역(데이터, 힙, 스택)에 나뉘어 관리

## 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다
프로세스 주소 공간 구조에서 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 malloc 함수를 호출하면 둘 다 0x7f64cb8을 반환하는 등 동일한 시작 주소를 반환할 가능성이 매우 높다. 그렇다면 이 두 프로세스가 모두 주소 0x7f64cb8에 데이터를 쓸 수 있다는 건데 이것이 문제되지는 않을까? 문제되지 않는다. 왜냐면 0x7f64cb8라는 메모리 주소는 가짜 주소이며, 이 주소는 메모리에 조작이 이렁나기 전에 실제 물리 메모리 주소에 변경된다. 다시 말해 코드, 데이터, 힙, 스택 같은 구조는 가상적인 구조에 불과하고, 실제 메모리에는 애초에 이런 형태의 구조가 존재할 수 없다. 오히려 실제 물리 메모리의 모습은 각 프로세스의 영역이 조각으로 나뉘어져 중구난방으로 흩어져 있는 모습에 훨씬 가깝다. 즉, 실제 물리 메모리에서는 프로세스는 동일한 크기의 조각(chunck)로 나뉘어 물리 메모리에 저장된다 (ex. 프로세스의 힙 영역이 동일한 크기의 조각 x개로 나뉘어져 있다 - 힙 영역 파트1, 힙 영역 파트 2…), 그리고 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다. 이런 물리 메모리와 가상 메모리 사이에는 사상(mapping) 관계가 있고, 페이지 테이블(page table)이 존재한다.

## 페이지와 페이지 테이블: 가상에서 현실로
가상 메모리 주소 공간은 물리 메모리에 매핑되어 있다. 가상 메모리 주소와 물리 메모리 주소의 매핑 관계가 유지되는 한, 프로세스 주소 공간의 데이터가 실제 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다. 이런 사상 관계(maaping)을 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 한다. 여기서 주목할 만한 것은 모든 가상 주소를 물리 주소에 사상하는 대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 페이지(page)라고 부른다는 점이다. 이처럼 사상은 페이지 단위로 이루어지므로, 페이지 테이블이 가져야 하는 항목 수가 대폭 줄어든다. 이제 두 프로세스가 동일한 메모리 주소에 기록하더라도 문제가 발생하지 않는 이유를 알 수 있다. 이 메모리 주소가 가르키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문이다. (Ex. 프로세스 A 코드 영역 Part 2, 프로세스 B 코드 영역 Part 2). 따라서 표준적이고 깔끔하게 정리된 가상 주소 공간은 현실에는 존재하지 않으며, 단지 논리적인 표현에 불과하다. 이것이 바로 최신 운영 체제에서 매우 중요한 기능인 가상 메모리의 기본 구현 원리이다.

# 스택 영역: 함수 호출은 어떻게 구현될까?
함수 실행 시간 스택(runtime stack) 또는 함수 호출 스택(call stack)을 먼저 이해해 보자.

### 프로그래머를 위한 도우미: 함수
동일한 기능을 하는 코드는 매번 반복해서 작성할 필요가 없도록 함수에 담아 둘 수 있다. 함수는 가장 기초적이고 간단한 코드 재사용 방식이다. 또한 함수는 프로그래머가 구현의 세부 사항을 감출 수 있게 하므로, 함수를 호출할 때는 함수 이름, 매개변수, 반환값만 알면 된다. 함수가 어떻게 구현되어 있는지는 전혀 신경 쓸 필요가 없으며, 이 역시 일종의 추상화에 해당한다. 그렇다면 함수의 호출은 어떻게 구현된 것일까?

### 함수 호출 활동 추적하기: 스택
스택 상단의 작업 궤적은 후입선출(last in first out)의 순서로, 본질적으로 스택과 같은 데이터 구조가 처리하기에 적합하다. 또한 사실상 이진 트리(binary tree)의 탐색(search)이라는 것도 알 수 있다. 이것이 리너 트리 구조의 순회가 재귀 구현 뿐만 아니라 스택 구현에도 사용될 수 있는 이유이다.

### 스택 프레임 및 스택 영역: 거시적 관점
모든 함수는 실행 시에 자신만의 작은 상자가 필요하다. 이 상자 안에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 이 상자들은 스택 구조를 통해 구성된다. 여기에서 각각의 작은 상자를 스택 프레임(stack frame)또는 호출 스택(call stack)이라고 한다. 그리고 이 구조는 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다. 프로세스 스택 영역의 높은 주소(highest address)가 맨 위에 있고, 스택 영역은 낮은 주소 방향으로 커진다. 다시 말해, 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고, 함수 호출이 완료될수록 감소한다. 그렇다면 스택 프레임이라는 이 작은 상자 안에는 무엇이 들어 있을까? 이 질문에 답하려면 함수를 호출할 때 어떤 정보들이 포함되는지 이해해야 한다. 

### 함수 점프와 반환은 어떻게 구현될까?
함수 A가 함수 B를 호출하면 제어권이 함수 A에서 함수 B로 옮겨지고, 여기에서 제어권은 실제로 CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지를 의미한다. CPU가 함수 A의 명령어를 실행하다가 함수 B의 명령어로 점프하는 것을 제어권이 함수 A에서 함수 B로 이전되었다고 이야기한다. 제어권이 이전될 때는 다음 두 가지 정보가 필요하다: 반환(return) 즉, 어디에서 왔는지에 대한 정보. 그리고 점프(jump) 즉, 어디로 가는지에 대한 정보. 다시 말해, 함수 A가 함수 B를 호출할 때 함수 A의 기계 명령어가 어디까지 실행되었는지(어디에서 왔는지), 그리고 함수 B의 첫 번째 기계 명령어가 위치한 주소(어디로 가는지)를 알아야 한다. 이 두 가지 정보만 있으면, CPU에 함수 A에서 함수 B로 점프하여 명령어를 실행하게 한 후, 함수 B의 실행이 완료되면 다시 함수 A로 점프하게 할 수 있다. 바로 이런 정보가 스택 프레임에 담기는 것이다. 예를 들어 함수 A가 함수 B를 호출할 때 CPU가 함수 A의 기계 명령어를 실행하고 있다가 call 0x400540 같은 기계 명령어를 만나면 이에 대응하는 것은 코드의 함수 호출이므로 함수 B의 첫 번째 기계 명령어 주소인 함수 B의 0x400540로 CPU는 점프하게 된다. 또한 call 명령어 다음에 위치한 주소를 함수 A의 스택 프레임에 넣는다. 이것이 바로 함수 A의 반환주소이다. 즉, CPU는 함수 B의 대응하는 기계 명령어를 실행하기 시작하면 함수 B를 위한 새로운 스택 프레임이 추가되고 스택 영역이 차지하는 메모리 크기도 증가하는데, 함수 B의 마지막 기계 명령어인 ret까지 계속 실행한 다음 이 기계 명령어에 따라 CPU에 함수 A의 스택 프레임에 저장된 반환 주소로 점프한다. 이에 따라 함수 B의 실행이 완료되면, 바로 함수 A로 점프하여 계속 실행할 수 있다. 함수 A의 스택 프레임에 저장된 주소는 0x40056a이며, 이는 함수 A의 call 명령어 바로 다음 기계 명령어의 주소에 해당한다. 함수의 반환 주소 외에 또 어떤 정보가 스택 프레임에 저장될까?

### 매개변수 전달과 반환값은 어떻게 구현될까?
CPU는 기계 명령어를 실행할 때 점프와 반환이 가능하기 때문에 이를 이용해서 함수를 호출할 수 있었다. 하지만 함수를 호출할 때는 함수 이름 외에도 매개변수를 전달하고 반환값을 가져와야 한다. 이를 어떻게 구현할 수 있을까? X86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다. 함수 A가 함수 B를 호출한다면, 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다. 마찬가지로 함수 B도 반환값을 레지스터에 저장하고, 함수 B의 실행이 완료되면 이 레지스터에서 반환값을 가져올 수 있다.

그런데 CPU 내부의 레지스터 수는 제한되어 있다. 만약 전달된 매개변수 수가 사용 가능한 레지스터 수보다 많다면 어떻게 해야 할까? 함수가 가지고 있는 작은 상자인 스택 프레임이 다시금 힘을 발휘할 순간이다. 원래 매개변수 수가 레지스터 수보다 많으면 나머지 매개변수는 스택 프레임에 직접 넣을 수 있기 때문에, 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져오면 된다. 즉, 스택 프레임은 함수 호출에 필요한 매개변수를 보관한다. 함수 B를 호출할 때 매개변수 중 일부를 함수 A의 스택 프레임에 넣는 것이다.

### 지역 변수는 어디에 있을까?
함수 외부에 정의된 변수를 전역 변수라고 한다. 이 변수들은 실행 파일의 데이터 영역에 저장되어 있다가 프로그램이 실행되면 프로세스 주소 공간의 데이터 영역에 적재된다. 반면에, 함수 내부에서 정의된 변수는 지역 변수라고 하는데, 이 변수들은 해당 함수에서만 사용 가능하고 외부에서는 접근이 불가능하다. 이 지역변수들은 마찬가지로 레지스터에 저장될 수 있지만, 로컬 변수 수가 레지스터 수보다 많으면 이 변수들도 스택 프레임에 저장되어야 한다.

### 레지스터의 저장과 복원
그렇다면 레지스터는 CPU의 내부 리소스인데, CPU가 함수 A를 실행할 때 이런 레지스터를 사용하고 CPU가 함수 B를 실행할 때도 마찬가지로 이 레지스터를 사용한다면, 함수 A가 함수 B를 호출할 때 함수 A가 레지스터에 기록한 지역 변수 정보를 함수 B가 덮어써서 문제가 될 수도 있다. 따라서 레지스터에 지역 변수를 저장하게 전에, 반드시 먼저 레지스터에 원래 저장되었던 초깃값을 꺼냈다가 레지스터를 사용하고 나면 다시 그 초깃값을 저장해야 한다. 레지스터에 원래 저장되어 있던 값을 바로 함수의 스택 프레임에 저장하는 것이다. 함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초깃값을 상응하는 레지스터에 내용으로 복원하기만 하면 된다. 

### 스택 프레임과 스택 영역
스택 프레임은 스택 영역에 위치해 있다. 스택 영역은 프로세스 주소 공간의 일부이며, 스택 영역을 확대해 보면 레지스터 초깃값, 지역 변수, 매개 변수, 반환 주소를 담고 있다. 만약 어떤 함수가 자기 자신을 100,000,000 번 반복해서 호출한다면 함수가 매번 호출될 때마다 상응하는 스택 프레임은 함수 실행 시 정보를 저장하기 위해 실행되며, 함수 호출 단계가 증가함에 따라 스택 영역이 점점 더 많은 메모리를 차지하게 된다. 하지만 스택 영역의 크기에는 제한이 있으며, 이 제한을 초과하면 스택 넘친(stack overlfow) 오류가 발생한다. 따라서 프로그래머들은 너무 큰 지역 변수를 만들면 안 되고, 함수 호출 단계가 너무 많으면 안 된다. 매개 변수가 너무 많으면 일부 매개 변수가 스택에 저장되고, 레지스터 내용 중 일부는 스택 프레임에 저장된다. 그렇다면 매개변수가 너무 많아서 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까? 스택 영역의 증가와 감소는 구체적으로 어떻게 구현될까? 그리고 이를 구현한 책임은 누구에게 있을까? 프로세스 주소 공간으로 돌아가 스택 영역의 아래는 유휴 영역(free segment)이 존재한다. 스택 영역이 계속 증가하면 유휴 영역을 점유하기 시작하는데, 이 영역에도 물론 역할이 존재한다. 프로그램이 동적 라이브러리에 의존하는 경우에는 프로그램이 사용하는 동적 라이브러리가 이 영역에 적재된다. 

# 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?
스택 영역은 함수 호출과 밀접한 관련이 있다. 모든 함수에는 각자만의 스택 프레임이 있으며, 이 안에는 반환 주소, 함수의 지역 변수, 매개변수, 사용되는 레지스터를 비롯한 정보가 저장된다. 스택 프레임은 스택 영역 내에 구성되기 때문에 함수의 호출 단계가 증가할 때마다 스택 영역이 차지하는 메모리가 늘어난다. 반면에 함수 호출이 완료되면 기존 스택 프레임 정보는 더 이상 사용되지 않으므로 스택 영역이 차지하는 메모리는 그만큼 줄어든다. 프로그래머는 앞선 내용을 기반으로 두 가지 내용에 주의해야 한다.

1. 함수 A가 함수 B를 호출할 때, 함수 B에 대한 호출 과정이 완료되면 스택 프레임에 저장되어 있던 내용은 더 이상 사용되지 않고 무효화(invalidation)된다. 따라서 프로그래머는 무효화된 스택 프레임 내용에 대해 어떤 가정도 해서는 안 된다. 예를 들어 함수 B가 스택 프레임에 저장되어 있던 지역 변수 데이터에 대한 포인터를 반환하는 것처럼, 이미 사용이 끝난 스택 프레임 정보를 사용해서는 안 된다.
2. 지역 변수의 수명 주기(lifecycle)은 함수 호출과 동일하다. 이것의 장점은 프로그래머가 지역 변수가 차지하는 메모리의 할당과 반환 문제에 신경 쓸 필요가 없으며, 함수를 호출할 때 지역 변수가 바로 스택 프레임에 저장된다는 것이다. 함수 호출이 완료되면 스택 프레임 내용이 무효화되며, 스택 프레임이 사용하던 메모리를 다른 함수에서 가져와 사용할 수 있으므로, 이것이 직접 지역 변수가 사용할 메모리의 할당과 반환 문제에 신경을 쓸 필요가 없는 이유이다.반면이 지역 변수의 단점은 함수를 뛰어넘어 사용하는 것이 불가능하다는 것인데, 함수가 반환된 후에는 지역 변수가 저장되어 있던 메모리가 더 이상 유효하지 않기 때문이다. 동시에 이것은 지역 변수는 프로그래머의 관리 대상이 아니라는 것을 의미하기도 한다. 물론 함수 A가 함수 B를 호출한 상태에서 함수 B가 함수 A의 지역 변수를 사용하는 것처럼 지역 변수를 사용하는 시점에 해당 변수가 저장된 스택 프레임이 여전히 유효한 상태라는 것을 확인할 수 있다면, 함수 외부에서 지역 변수를 사용한 데 문제는 없다. 

## 힙 영역이 필요한 이유
그렇다면 특정 데이터를 여러 함수에 걸쳐 사용해야 한다면? 전역 변수를 사용할 수도 있지만 전역 변수는 모든 모듈에 노출되어 있고, 때로는 데이터를 모든 모듈에 노출하고 싶지 않을 때도 있다. 프로그래머는 이런 데이터를 직접 관리하는 특정 메모리 영역에 저장해야 하며, 프로그래머는 이런 메모리 영역을 언제 요청할지와 데이터를 저장하는 데 얼마나 많은 메모리 영역을 요청할지 직접 결정해야 한다. 이 메모리는 함수의 호출 횟수와 관계없이 프로그래머가 해당 메모리 영역의 사용이 완료되었다고 확신할 때까지 유효하게 유지된다. 이후 해당 메모리는 무효화되며, 이 과정을 동적 메모리 할당과 해제라고 한다. 이와 같은 이유로 메모리 수명 주기에는 프로그래머가 완전히 직접 제어할 수 있는 매우 큰 메모리 영역이 필요하며, 이 영역을 바로 힙 영역(heap segment)라고 한다.
C/C++ 언어에서는 malloc 함수 또는 new 예약어를 사용해서 힙 영역에 메모리를 요청하며, free 함수나 delete 예약어를 이용해서 해당 메모리를 반환한다. 이것이 힙 영역이 가진 모든 비밀이다. 단순히 프로그래머가 수명 주기를 결졍할 수 있는 메모리 영역을 제공하는 역할이 전부다. 힙 영역에서 메모리 할당과 해제는 어떻게 구현될까? 이 문제를 파악하려면 malloc과 유사한 메모리 할당자를 직접 구현해 보아야 한다. 

### malloc 메모리 할당자 직접 구현하기
C/C++ 언어에서 메모리의 동적 할당과 해제 요청은 모두 전문적으로 힙 영역에 메모리를 할당하고 해제하는 작은 프로그램에 전달되어 처리되는데, 이 프로그램이 바로 malloc 메모리 할당자이다.
실제로 실행 파일을 생성할 때 링커는 C 표준 라이브러리(C standard library)를 자동으로 링크하며, 이 표준 라이브러리 내 malloc 메모리 할당자가 포함되어 있다. 따라서 프로그래머는 직접 메모리 할당을 구현할 필요 없이 프로그램 내에서 malloc을 호출하여 메모리를 할당할 수 있다. 

할당자 입장에서는 적절한 크기의 메모리 영역을 제공하기만 하면 되고, 할당자는 그 메모리 영역에 무엇을 저장할지까지는 신경 쓰지 않는다. 정수(integer), 부동 소수점 숫자(floating number), 연결 리스트(linked list), 이진 트리(binary tree)처럼 단순한 것부터 복잡한 것까지 어떤 구조의 데이터도 모두 저장할 수 있으며, 메모리 할당자가 보기에 이런 데이터는 단순한 바이트의 연속에 지나지 않는다. 사실 힙은 커다란 배열 형태로 매우 간단한 구조로 되어 있다.
이제 힙 영역 위에서 두 가지 문제를 해결해 나가면 된다. 메모리 할당자가 해결해야 할 두 가지 핵심 문제이다:
1. Malloc 함수를 구현한다. 이 함수는 누군가 나에게 메모리 영역을 요청하면 힙 영역에서 가능한 메모리 영역을 찾아 요청자에게 반환하는 과정을 구현하는 것이다.
2. Free 함수를 구현한다. 이 함수는 메모리 영역의 사용이 완료되었을 때, 힙 영역에 이 메모리 영역을 반환하는 방법을 구현하는 것이다. 

### 주차장에서 메모리 관리까지
요청하는 메모리의 크기는 일정하지 않다. 요청된 크기를 만족하는 여유 메모리를 찾되, 가능한 많은 메모리를 적재할 수 있어야 하기 때문에 메모리를 요청할 때는 정해진 메모리 한도 내에서 가능한 한 많은 메모리 할당 요청을 만족시켜야 한다. 이를 위해 세 가지 문제가 있다. 1) 메모리 조각을 조직화해서 모든 메모리 조각의 할당 상태를 어떻게 추적할지. 2) 메모리 할당 요청의 요구 사항을 만족하는 사용 가능한 메모리 조각이 매우 많을 때, 어떤 여유 메모리 조각을 사용자에게 반환할지. 3) 특정 크기의 메모리를 요청해야 하는데 찾은 여유 메모리 조각의 크기가 더 커서 남은 메모리가 있는데, 이 남은 메모리를 어떻게 처리할지. 4) 이렇게 사용자가 반환한 메모리를 우리는 어떻게 처리해야 하는지.  

### 여유 메모리 조각 관리하기
사용 가능한 메모리 조각을 관리하기 위해서는 어떤 영역이 사용 가능한 메모리고, 어떤 영역이 이미 할당된 메모리인지 구분하는 방법이 필요하다. 연결 리스트(linked list)는 비교적 간단히 이를 구현할 수 있는 방법이다. 모든 메모리 조각을 연결 리스트로 관리할 수 있으며, 어떤 것이 사용 가능하고, 어떤 것이 이미 할당된 것인지 기록하기도 편리하다. 그런데 먼저 연결 리스트를 생성하고 여기에 정보를 기록할 수 없음을 주의해야 한다. 왜냐하면 연결 리스트를 생성하려면 메모리를 할당받아야 하는데, 이를 위해서는 메모리 할당자를 사용해야 한다. 하지만 지금 하려는 작업은 바로 그 메모리 할당자를 구현하는 것이며, 아직 존재하지 않는 메모리 할당자에 메모리를 요청한다는 자가당착에 빠지는 것이다. 물론 메모리 할당자를 사용하지 않을 수도 있지만 매우 번거로울 것이다. 따라서 연결 리스트와 메모리 사용 정보를 메모리 조각 그 자체에 함께 저장해야 한다. 여기에서 메모리 조각은 할당 또는 해제된 전체 메모리 조각을 의미한다. 이 연결리스트에는 다음 노드(node)가 어디 있는지 알려 주는 포인터가 없지만, 메모리 사용 정보로 다음 노드 위치를 유추하는 것이 가능하다.
정리하자면 구현 방법엔 다음 두 가지 정보만 기록하면 된다: 1) 해당 메모리 조각이 비어 있는지 알려 주는 설정값(flag), 2) 해당 메모리 조각의 크기를 기록한 숫자. 최대한 간단하게 구현하기 위해 메모리 정렬(memory alignment)는 하지 않으며, 단일 메모리 할당에 허용되는 최대 크기는 2GB라고 단순히 구현을 쉽게 하기 위해 가정한다. (세부 내용을 다루지 않는 것일 뿐 일반적으로 사용되는 malloc과 같은 할당자에는 이런 제한이 없다는 점을 잊지 말아야 한다). 메모리 조각의 최대 크기가 2GB로 제한되어 있기 때문에 31비트를 사용해서 조각 크기를 기록하고, 나머지 1ㅂ비트는 조각이 비어 있는지 또는 할당되어 있는지 인식하는 데 사용할 수 있다. 참고로 f/a는 free/allocated를 뜻하는 것으로, f는 비어 있음을 나타내고, a는 할당되어 있음을 나타낸다. 이 32비트는 머리 정보(header)라고 하며, 메모리 조각의 사용 정보를 저장하는 데 쓴다. 그리고 그 아래에 할당 가능한 메모리 조각을 페이로드(payload)라고 하며, 우리가 malloc을 호출하면 반환되는 메모리 주소가 바로 여기에서 시작된다.
이제 왜 이것이 연결리스트를 형성하는지 알았다. 메모리 조각을 유지 관리하는 머리 정보 크기는 항상 32비트로 고정되어 있으며, 각 메모리 조각 크기도 머리 정보에서 얻을 수 있다. 머리 정보 주소만 알고 있다면 해당 머리 정보 주소에 메모리 조각 크기를 더해 다음 노드의 시작 주소를 알 수 있는 것이다. 이와 같이 힙 영역의 모 든 메모리를 남김없이 할당하는 것은 불가능하며, 그 중 일부분은 여기에서 설명한 머리 정보처럼 메모리 조각에 대한 필수 정보를 저장하기 위해 별도로 사용되어야 한다.

### 첫번째 문제: 메모리 할당 상태 추적하기
다음과 같은 방식으로 메모리 할당과 해제를 위해 힙 영역을 조직화할 수 있다. 힙 영역은 한 조각에 4바이트인 매우 작은 영역으로, 할당된 메모리 조각과 여유 메모리 조각을 나타내고 있다. 메모리 조각에는 빗금으로 칠한 머리 정보가 있는데, 예를 들어 16/1은 할당된 메모리 조각 크기가 16바이트임을 의미하고, 32/0은 여유 메모리 조각이 32바이트임을 의미한다. 마지막 조각의 0/1은 연결 리스트와 마찬가지로 메모리 할당자에도 끝(tail node)를 알려주는 특수한 표시(sentinel)이 필요하며, 이를 위해 마지막 4바이트를 사용한다. 머리 정보를 도입한 이런 설계는 전체 힙 영역을 쉽게 추적할 수 있다. 또 추적 과정에서 머리 정보의 마지막 비트를 확인하여 메모리 조각이 여유 상태인지 또는 할당되었는지 확인할 수 있어서, 메모리 조각의 할당 정보를 추적할 수 있다. 

### 두번째 문제: 어떻게 여유 메모리 조각을 선택할 것인가: 할당 전략
메모리를 요청할 때 메모리 할당자는 적절한 크기의 여유 메모리 조각을 찾아야 한다. 만약 4바이트 메모리를 요청해야 한다고 가정했을 때, 이런 요구 사항을 충족하는 여유 메모리가 8바이트 메모리 조각과 32바이트 메모리 조각이 있다면 둘 중 어떤 것을 반환해야 할까? 이것은 할당 전략의 문제이며, 실제로 선택할 수 있는 전략은 많다.

1. 최초 적합 방식(first fit)
매번 처음부터 탐색하다가 가장 먼저 발견된 요구 사항을 만족하는 항목을 반환하는 것이다. 이 방식의 장점은 단순하지만, 단점은 항상 제일 처음부터 사용 가능한 메모리 조각을 찾으므로 메모리 할당 과정에서 앞부분에 작은 메모리 조각이 많이 남을 가능성이 높다. 이렇게 되면 다음 메모리를 할당할 때 더 많은 여유 메모리 조각을 탐색해야 하는 문제가 있다.

2. 다음 적합 방식(next fit)
문자열 검색에 사용되는 커누스-모리스-프랫 알고리즘(Knuth-Morris-Pratt algorithm)의 창시자 중 한 명인 도널드 커누스가 제인한 방식이다. 다음 적합 방식은 최초 적합 방식과 매우 유사하지만, 메모리를 요청할 때 처음부터 검색하는 대신, 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작한다는 점이 다르다. 이론적으로 다음 적합 방식은 최초 적합 방식보다 더 빠르게 여유 메모리 조각을 탐색할 수 있다. 그러나 다음 적합 방식의 메모리 사용률은 최초 적합 방식에 미치지 못한다는 것이 연구로 밝혀졌다.

3. 최적 적합 방식(best fit)
최초 적합 방식과 다음 적합 방식은 요구 사항을 충족하는 첫 번째 여유 메모리 조각이 발견되는 즉시 반환되지만, 최적 적합 방식은 그렇지 않다. **최적 적합 방식은 먼저 사용 가능한 메모리 조각을 모두 찾은 후, 그중 요구 사항을 만족하면서 크기가 가장 작은 조각을 반환**한다. 예를 들어 최적 접학 방식은 요구 사항을 충족하는 여유 메모리 세 조각 중에 크기가 가장 작은 8바이트 크기의 여유 메모리 조각을 선택하는 것이다. 최적 적합 방식이 최초 적합 방식과 다음 적합 방식보다 메모리를 더 잘 활용한다는 것은 직관적으로 알 수 있다. 그러나 최적 적합 방식의 가장 큰 단점은 메모리를 할당할 때 사용 가능한 모든 메모리 조각을 탐색해야 하므로 최초 적합 방식이나 다음 적합 방식만큼 빠르지 않다는 것이다. 

다음 적합 방식은 요구 사항을 충족하는 첫 번째 여유 메모리 조각이 발견되는 즉시 반환되지만, 최적 적합 방식은 그렇지 않다. **최적 적합 방식은 먼저 사용 가능한 메모리 조각을 모두 찾은 후, 그중 요구 사항을 만족하면서 크기가 가장 작은 조각을 반환**한다. 예를 들어 최적 접학 방식은 요구 사항을 충족하는 여유 메모리 세 조각 중에 크기가 가장 작은 8바이트 크기의 여유 메모리 조각을 선택하는 것이다. 최적 적합 방식이 최초 적합 방식과 다음 적합 방식보다 메모리를 더 잘 활용한다는 것은 직관적으로 알 수 있다. 그러나 최적 적합 방식의 가장 큰 단점은 메모리를 할당할 때 사용 가능한 모든 메모리 조각을 탐색해야 하므로 최초 적합 방식이나 다음 적합 방식만큼 빠르지 않다는 것이다.

### 세 번째 문제: 메모리 할당할 때 잔여로 남은 메모리에 대한 처리
예를 들어 12바이트 메모리를 요청했을 때, 할당을 위해 발견된 여유 메모리 조각의 크기가 12바이트라고 가정해 보자. 이제 이 조각을 할당된 것으로 표시하고 머리 정보 뒤에 따라오는 메모리 조각의 주소를 요청자에게 반환하기만 하면 된다. 이때 머리 정보를 담고 있는 메모리는 요청자에게 반환되면 안 된다. 일단 이 정보가 손상되면 메모리 할당자가 정상적으로 작동할 수 없기 때문이다. 머리 정보 뒤 메모리 주소를 반환하고 할당된 것으로 표시하면 한 번의 메모리 할당이 완료된다.
그러나 이것은 이상적인 상황이며, 12바이트 메모리를 요청했을 때 찾아낸 여유 메모리가 12바이트보다 더 큰 경우가 대부분일 것이다. 만약 찾아낸 조각의 크기가 32바이트라면 이 32바이트의 여유 메모리 조각을 전부 할당해야 할까? 이 방법이 가장 빠르지만, 메모리가 낭비되고 내부 단편화(fragmentation)이 발생하게 되어, 해당 메모리 조각의 남은 부분은 사용할 방법이 없다.
이 문제를 해결하는 확실하면서도 자주 사용하는 방법은 여유 메모리 조각을 두 개로 분할하여 앞부분은 할당한 후 반환하고, 뒷부분은 좀 더 작은 크기의 새로운 여유 메모리 조각으로 만드는 것이다. 여유 메모리 조각의 크기를 32바이트에서 16바이트로 변경해야 하는데, 이 중에서 머리 정보의 4바이트를 제외한 나머지 12바이트가 발당된다. 설정값을 1로 하여 해당 조각이 할당 상태임을 표시한다. 이렇게 16바이트를 할당하고 나면, 16바이트가 남으므로 이 중에서 4바이트를 머리 정보로 설정하고 여유 메모리 조각으로 표시해야 한다.

### 네 번째 문제: 메모리 해제하기
단순히 메모리를 해제하는 것은 비교적 간단하다. 사용자가 메모리를 요청할 때 얻은 주소를 ADDR이라고 가정하면, 이 메모리를 해제할 때도 free 같은 해제 함수에 이 주소를 전달하기만 하면 된다. 즉, free(ADDR)처럼 호출하면 free 함수가 매개변수인 ADDR로 전달된 주소에서 머리 정보 크기인 4바이트를 빼는 것으로 해당 메모리 조각의 머리 정보를 얻을 수 있다. 그리고 이 머리 정보에서 해당 설정값을 여유 메모리로 바꾸면 해제가 완료된다. 이것이 메모리를 해제하기 위해 free 함수를 호출할 때, 해제할 메모리 조각 크기를 전달할 필요 없이 주소만 전달하는 이유이다.
또한 이와 동시에 메모리를 해제할 때 중요한 것이 하나 있다. 해제되는 메모리 조각과 인접한 메모리 조각이 여유 메모리 조각일 때, 메모리 조각을 해제한 후 단순하게 해제 여부만 기록한다면 문제가 발생하게 된다. 만약 다음에 20바이트 요청이 있을 때, 해제할 메모리 조각에 인접한 아래쪽 메모리 조각도 비어 있고 두 메모리 조각이 각각 16바이트라면, 두 메모리 조각의 합계가 20바이트를 훌쩍 뛰어넘음에도 메모리 두 조각 중 어느 것도 이 요구 사항을 만족시키지 못한다. 따라서 인접한 메모리 조각이 비어 있을 때는, 더 큰 메모리 조각으로 서로 병합하는 것이 더 나은 접근 방식이다.
여기서 또 다른 선택에 직면한다. 메모리를 해제할 때 인접한 여유 메모리 조각을 직시 병합해야 할까, 아니면 다음 할당 때 요구 사항을 충족하는 여유 블록을 찾을 수 없을 때까지 병합을 연기해야 할까? 메모리가 해제될 때 즉시 병합하는 것은 비교적 간단하지만, 메모리가 해제될 때마다 메모리 조각을 병합한다면 그에 따른 부담이 발생한다. 응용 프로그램이 크기가 같은 메모리 조각을 계속 할당과 해제를 반복한다면, 이런 메모리 사용 페턴은 여유 메모리 조각을 즉시 병합하는 전략과 상극이기 때문에 메모리 할당자가 불필요한 작업을 많이 수행하지만, 가장 간단해서 여전히 이 전략을 많이 선택하여 사용한다. 하지만 실제 메모리 할당자는 거의 대부분 여유 메모리 조각 병합을 연기하는 일종의 전략을 세우고 있다.

### 여유 메모리 조각을 효율적으로 병합하기
예를 들어서 해제되는 메모리 조각의 앞과 뒤가 모두 비어 있을 때, 현재 위치에서 x바이트만 아래로 이동하면 바로 다음 메모리 조각이므로, 이 메모리 조각이 비어 있다는 것은 쉽게 알 수 있다. 그렇다면 앞에 위치한 메모리 조각이 비어 있는지 여부는 어떻게 효율적으로 알 수 있을까? 도널드 커누스는 이를 해결하기 위해 매우 효과적인 설계를 제안했다. 우리가 앞으로 넘어가지 못하는 이유는 이전 메모리 조각에 대한 정보를 모르기 때문인데, 어떻게 해야 빠르게 이전 메모리 조각 정보를 얻을 수 있을까?
메모리 조각은 이미 머리 정보를 가지고 있는데, 마찬가지로 메모리 조각 끝에 다시 꼬리 정보(footer)을 추가할 수 있다. 꼬리 정보라는 단어는 매우 직관적이며, 머리 정보와 꼬리 정보의 내용은 같을 수 있다. 이전 정보의 꼬리 정보는 그다음에 위치한 조각의 머리 정보와 인접해 있어 현재 조각의 머리 정보에서 4바이트를 빼면 이전 조각의 꼬리 정보를 획득할 수 있다, 따라서 메모리를 해제할 때 인접한 여유 조각을 빠르게 병합할 수 있다. 이렇게 머리 정보와 꼬리 정보는 메모리 조각을 일종의 암시적 양방향 연결 리스트(doubly linked list)로 만든다.
이렇게 메모리 할당자 설계가 완료되었다. 하지만 실제로 메모리 할당자 설계는 이렇게 단순하지 않으며, 최적할 곳이 산더미처럼 많고, 스레드 안전 문제도 고려해야 한다. 실제 메모리 할당자는 매우 복잡하지만, 가장 기본적인 원리는 여기서 설명한 것과 같다. 최신 컴퓨터 시스템은 메모리 할당 작업을 약간 복잡하게 바꾸지만, 매우 흥미롭다. 저수준 계층 관점에서는 메모리를 할당할 때 어떤 일들이 벌어질까?

# 메모리를 할당할 때 저수준 계층에서 일어나는 일
### 천지인과 CPU 실행 상태
코드 역시 여러 가지 등급으로 나뉘며, 프로그램이 실행되는 배경에 천지인에 해당하는 몇 가지 단계가 존재한다. X86 CPU는 네 가지 특권 단계(privilege leve)를 제공한다. 0, 1, 2, 3이라는 숫자는 실제로 CPU의 여러 가지 동작 상태를 나타내며, 숫자가 작을수록 CPU의 특권(privilege)은 커진다. 여기서 특권은 일부 명령어를 실행할 수 있는지를 나타내며, 일부 기계 명령어는 CPU가 가장 높은 특권 상태일 때만 실행 가능하다. 예를 들어서 특권 0단계일 때 특권이 가장 커지며, 모든 기계 명령어를 실행할 수 있다. 일반적으로 시스템은 CPU의 특권 단계 중 0과 3 두 단계만 사용한다. 이 중 특권 3단계는 사용자 상태(user mode)라고 하며, 특권 0단계는 커널 상태(kernel mode)라고 한다.

### 커널 상태와 사용자 상태
CPU가 운영 체제의 코드를 실행할 때 바로 커널 상태에 놓인다. 커널 상태에서는 CPU가 모든 기계 명렁어를 수행할 수 있고, 모든 주소 공간에 접근할 수 있으며, 제한 없이 하드웨어에 접근할 수 있다. 운영 체제는 무엇이든 할 수 있다.
반면에 프로그래머가 작성한 일반적인 코드를 CPU가 실행할 때는 사용자 상태에 해당한다. 사용자 상태 코드는 여러 곳에서 제한을 받는데, 특히 특정 주소 공간에는 절대 접근할 수 없다. CPU는 사용자 상태일 때 또한 특권 명령어를 실행할 수 없다는 제한도 있다. 

### 포털: 시스템 호출
CPU는 커널 상태에서는 응용 프로그램을 실행할 수 없는 반면, 사용자 상태에서는 운영 체제의 코드를 실행할 수 없다. 그렇다면 응용 프로그램이 파일 읽기나 쓰기, 네트워크 데이터 송수신 등 운영 체제의 서비스를 요청해야 한다면 어떻게 해야 할까? 프로그래머가 시스템 호출(system call)을 하면 운영 체제가 파일의 읽기와 쓰기, 네트워크 통신과 같은 작업을 대신 처리해 준다. 시스템 호출은 x86의 INT 명령어처럼 특정한 기계 명령어로 구현되고, 이 명령어를 실행할 때 CPU는 사용자 상태에서 커널 상태로 전환되어, 운영 체제의 코드를 실행하는 방법으로 사용자 요청을 수행한다. 이런 관점에서 보면, 프로세스는 네트워크 통신에서 클라이언트(client)에 비할 수 있고, 운영 체제는 서버(server)에 비할 수 있다. 그리고 시스템 호출은 네트워크 오청에 해당한다. 그런데 이런 시스템 호출은 모두 별도의 장소에 담겨 있어 보통은 프로그래머가 직접 시스템 호출을 할 필요가 없다.

### 표준 라이브러리: 시스템의 차이를 감춘다
원래 시스템 호출은 모두 운영 체제와 밀접한 관련이 있으며, 리눅스의 시스템 호출은 윈도의 시스템 호출과 완전히 다르다. 만약 프로그래머가 직접 시스템 호출을 직접 사용하면, 리눅스의 프로그램은 윈도에서 직접 실행할 수 없게 된다. 따라서 사용자에게서 저수준 계층 간 차이를 감추는 일종의 표준이 필요하다. C 언어이서 이 일을 하는 것이 바로 표준 라이브러리(standard library)이다.
표준 라이브러리의 코드는 사용자 상태에서도 실행된다. 일반적으로 프로그래머는 표준 라이브러리를 호출하여 파일의 읽고 쓰기 작업과 네트워크 통신을 수행하며, 표준 라이브러리는 실행 중인 운영 체제에 따라 대응되는 시스템 호출을 선택한다. 계층적인 관점에서 보면, 계층 구조는 다음과 같이 이루어져 있다: 응용 프로그램 - 표준 라이브러리 - 운영 체제 - 하드웨어. 고수준 계층에는 응용 프로그램이 자리하고 있는데, 응용 프로그램은 일반적으로 표준 라이브러리만 의사소통 대상으로 간주한다. 표준 라이브러리는 시스템 호출로 운영 체제와 소통하며, 운영 체제는 저수준 하드웨어를 관리한다. 이것이 C언어에서 동일한 open 함수를 사용하여 리눅스뿐만 아니라 윈도에서도 파일을 열 수 있는 이유이다. 
- Context는 안드로이드에서 운영 체제 수준의 기능을 애플리케이션에 제공하는 수단이다. 예를 들어, Context를 사용해 시스템의 파일 디렉토리에 접근하거나, 서비스를 시작하거나, 리소스를 읽는 작업을 수행할 수 있다. (파일 읽기/쓰기, 리소스 접근, 서비스 관리, 브로드캐스트 전송, 시스템 서비스 요청 등 다양한 작업에서 필요한 운영 체제의 자원을 애플리케이션에 제공)
  Malloc 같은 메모리 할당자는 사실 운영 체제의 일부분이 아니라 표준 라이브러리의 일부로 구현되어 있다. C 언어에서 기본적으로 사용되는 malloc은 여러 종류의 메모리 할당자 중 하나에 불과하며, 이 외에도 tcmalloc, jemalloc 등 다양한 유형의 메모리 할당자가 있다는 것을 기억한다. 이런 메모리 할당자는 각자 적합한 활용 방식이 있으므로, 특정 상황에 가장 적합한 메모리 할당자를 선택하는 것이 매우 중요하다.

### 힙 영역의 메모리가 부족할 때
만약 메모리 할당자 안의 여유 메모리 조각이 부족해지면 어떻게 해야 할까? 프로그램이 메모리 내에 다음과 같은 형태로 존재한다 ㅡ 프로세스 주소 공간: 스택 영역, 유휴 영역, 힙 영역, 데이터 영역, 코드 영역. 이처럼 힙 영역과 스택 영역 사이에는 여유 공간이 있다. 스택 영역이 함수 호출 단계가 깊어질수록 아래쪽으로 메모리 점유 공간이 늘어나는 것처럼, 힙 영역의 메모리가 부족하면 위쪽으로 더 많은 메모리를 점유하게 된다. 힙 영역이 늘어나면 점유하는 메모리가 더 많아지므로, 여유 메모리 조각이 부족한 문제가 해결된다. 하지만 어떻게 해야 힙 영역을 늘릴 수 있을까?
원래 malloc은 메모리가 부족해지면 운영 체제에 메모리를 요청해야 하는데, 리눅스의 모든 프로세스에는 brk 변수가 있다. Brk 변수는 브레이크(break)를 의미하며, 힙 영역의 최상단을 가리킨다. 바로 이 brk 변수 값을 위로 이동해서 힙 영역을 확장하려면, 시스템 호출이 필요한 것이다.

### 운영 체제에 메모리 요청하기: brk
리눅스에서는 brk라는 전용 시스템 호출을 제공하는데, 앞서 언급했던 힙 영역의 상단 주소를 brk 시스템 호출을 이용하여 조절하는 방식으로 힙 영역 크기를 늘리거나 줄일 수 있다. 사실 brk 시스템 호출 외에 mmap 등 시스템 호출도 같은 목적으로 사용할 수 있는데, mmap이 좀 더 구조가 유연하다. 하지만 여기에서 중요한 것은 어떤 함수가 존재하느냐가 아니다. 여기섲 중요한 점은 이런 시스템 호출이 있으므로, 힙 영역이 부족하면 즉시 운영 체제에 힙 영역을 늘릴 것을 요청할 수 있고, 이것으로 더 많은 여유 메모리를 확보할 수 있다는 것이다. 이제 메모리 할당이 더 이상 사용자 상태의 힙 영역에만 국한되지 않기 떄문에, 메모리 할당 단계가 다음과 같이 달라질 수 있다: