# 비동기와 동기

## 전화 통화와 이메일 보내기
- 동기: 종속적, 연관된. 기다림. ex) 전화 통화에서의 대화
- 비동기: 비종속적, 무관한, 기다릴 필요 없는, 동시 발생 ex) 이메일 보내기 

## 동기 호출
funA의 함수가 funB를 호출하면, funB 함수 실행이 오나료될 때까지 funA 함수의 나머지 코드는 실행되지 않는다. 다시 말해 funA 함수는 반드시 funB 함수 실행이 완료될 때까지 기다려야 하며, 이것이 바로 동기 호출이다. 일반적으로 동기 호출에서는 funA 함수와 funB 함수가 동일한 스레드에서 실행되고, 이는 자주 볼 수 있는 상황이다. 

하지만 비교적 특수한 상황이 있는데, 입출력 작업이다. 
```
read(file, buf); // 여기에서 실행이 일시 중지된다.
// 파일 읽기가 완료될 때까지 기다렸다가 계속 실행한다. 
```
read 함수를 호출하여 파일을 읽는다고 가정할 때, 최하단 계층은 실제로 시스템 호 출(system call)로 운영 체제에 요청을 보낸다. 이때 운영 체제는 파일 읽기 작업을 위해 호출 스레드를 일시 중지시키며, 커널이 디스크 내용을 읽어 오면 일시 중지되었던 스레드가 다시 깨어난다. 이것이 바로 블로킹 입출력(blocking input/output)이다. 

물론 이것도 동기 호출이다. 단지 호출자와 파일을 읽는 코드가 다른 스레드에서 실행되고 있을 뿐이다. 따라서 동기 호출은 호출자와 수신자가 같은 스레드에서 실행 중인지 여부와는 관련이 없다. 

동기 프로그래밍은 프로그래머가 이해하기에 가장 쉽지만, 일부 상황에서 호출자가 요청한 작업이 끝날 때까지 기다려야 하기 때문에 효율은 높지 않다.

## 비동기 호출
- 일반적으로 비동기 호출은 디스크의 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업처럼 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행한다.
- 예를 들어 read 함수의 호출이 동기 방식일 경우에는 호출자는 파일을 모두 읽을 때까지 계속 진행이 불가능하지만, read 함수가 비동기 호출되면 파일 읽기 작업이 완료되지 않은 상태에서도 read 함수는 즉시 반환될 수 있다.
```
read(file, buff); // read 함수는 즉시 반환된다.
// 이후 내용의 실행을 블로킹하지 않는다.
```
이 경우 호출자가 블로킹되지 않고 read 함수가 즉시 반환되기 때문에, 호출자는 즉시 다음 작업을 실행할 수 있다. 호출자의 이후 작업은 파일 읽기 작업과 동시에 진행되기 때문에, 비동기의 높은 효율성을 가지고 온다.
그러나 비동기 호출은 프로그래머가 이해하는 데 큰 부담이 될 수 있으며, 코드를 작성하는 것도 그렇다. 

동기 호출 방식에서는 해당 함수가 반환될 때 호출된 함수와 관련된 작업 처리가 모두 완료되었다고 확신할 수 있다. 다시 말해 read 함수를 동기 호출하면, 해당 함수가 반환될 때 파일 읽기 작업이 모두 완료되었음을 의미한다. 하지만 비동기 호출에서는 어떨까? 비동기 호출의 결과를 처리할 때는 두 가지 상황이 있을 수 있다.
- 호출자가 실행 결과를 전혀 신경 쓰지 않을 때: 콜백 함수로 핸들러를 넘긴다. 요청 처리와 콜백 실행을 호출되는 스레드에서 처리한다.
- 호출자가 실행 결과를 반드시 알아야 할 때: 호출되는 스레드에서 요청 처리를 한 후에 결과를 통지해주면, 호출하는 스레드에서 결과를 처리한다.

첫 번째 상황을 구현하기 위해 콜백 함수를 사용할 수 있다. 예를 들어서, read 함수를 비동기 호출할 때 파일 내용을 처리하는 함수를 함께 매개변수로 전달할 수 있다. 

```
void handler(void*buf) {
    ... // 파일 내용 처리 중
}
read(buf, handler);
```
read(buf, handler)의 의미는 다음과 같다. '계속해서 파일을 읽고, 작업이 오나료되면 전달된 함수를 사용해서 파일을 처리해 주세요.' 이때, 파일 내용은 호출자 스레드가 아닌 콜백 함수가 실행되는 다른 스레드, 혹은 프로세스 등에서 처리한다. 

두 번째 상황을 구현하는 방법 중 하나는 알림(notification) 작동 방식을 사용하는 것이다. 즉, 작업 실행이 완료되면 호출자에게 작업 완료를 알리는 신호나 메시지를 보내는 것이다. 이 경우 결과 처리는 이전과 마찬가지로 호출 스레드에서 한다. 일반적으로 함수의 비동기 호출에는 흔히 스레드 두 개가 사용되는데, 호출자가 하나의 스레드를 사용하고 실제 작업은 일반적으로 다른 스레드에서 실행된다. 즉, 호출하는 스레드에서 호출을 하면 호출되는 스레드에서 요청 처리를 하고, 결과를 통지하면 결과 처리는 다시 호출하는 스레드에서 하는 것이다. 



## 웹 서버에서 동기와 비동기 작업
예를 들어서 사용자 요청을 처리하기 위해 A, B, C 세 단계를 거친 후 데이터 베이스를 요청하고, 데이터 베이스 요청 처리가 완료되면 다시 D, E, F 세 단계를 거쳐야 작업이 완료된다고 가정해 본다. 여기서 입출력 작업이 필요한 유일한 단계는 데이터 베이스 요청 작업이다. 
일반적으로 이런 형태의 웹 서버에는 주 스레드와 데이터베이스 처리 스레드라는 전형적인 스레드 두 개가 있다. 

전형적인 동기 처리 방법: 데이터베이스 요청 후 주 스레드가 블로킹되어 일시 중지되며, 데이터베이스 처리가 완료된 시점에서 이후 단계인 D, E, F가 계속 실행된다. 
```
// 메인 스레드
main_thread() {
    while (1) {
        요청 수신;
        A;
        B;
        C;
        데이터베이스 요청을 전송하고 결과가 반환될 때까지 대기;
        D;
        E;
        F;
        결과 반환;
    }
}

// 데이터베이스 스레드
database_thread() {
    while (1) {
        요청 수신;
        데이터베이스 처리;
        결과 반환;
    }
}
```
그 결과 주 스레드 가운데는 데이터 베이스를 요청을 전송하고 결과가 반환될 때까지 대기하며 비는 시간인 "빈 공간"이 존재하며, 이것이 바로 주 스레드의 유휴 시간(idle tiem)이다. 주 스레드는 이 유후 시간동안 데이터베이스 처리가 완료될 때까지 기다려야 다음 과정을 처리할 수 있다. 

반면 비동기 구현에서는 주 스레드가 데이터베이스 처리가 완료될 때까지 기다리는 대신, 데이터베이스 처리 요청을 전송하자마자 바로 다음에 넘어온 새로운 사용자 요청을 직접 처리한다. 

1) 첫 번째 상황: 주 스레드가 데이터베이스 처리 결과를 전혀 신경쓰지 않을 때
이때 주 스레드는 데이터베이스 처리 완료 여부에 상관하지 않는다. 데이터베이스 처리가 완료된 후 주 스레드가 아닌 데이터베이스 스레드가 다음 D, E, F 세 단계를 자체적으로 직접 처리한다. 이를 위해 콜백 함수를 사용해 D, E, F 세 단계를 첫 번째 함수에 담고, 함수 이름을 handle_DEF_after_DB_query로 지정해서, 주 스레드가 데이터 베이스 처리 요청을 보낼 때 이 함수를 매개변수로 전달한다.
```
void handle_DEF_after_DB_query() {
    D;
    E;
    F;
}

DB_query(request, handle_DEF_after_DB_query);
```
이제 데이터베이스 스레드는 데이터베이스 요청을 처리한 후 직접 handle_DEF_after_DB_query 함수를 호출하기만 하면 되고, 이것이 바로 콜백 함수가 하는 일이다.

이 함수를 데이터베이스 스레드에 정의하고 직접 호출하는 대신, 콜백 함수를 통해 전달받아 실행하는 이유는 소프트웨어 조직 구조 관점에서 볼 때, 이 작업이 데이터베이스 스레드에서 해야 할 작업이 아니기 때문이다. 따라서 데이터베이스 스레드 입장에서는 자신의 주 업무인 데이터베이스를 처리하고 나서 콜백 함수를 호출하면, 자신의 임무가 완료된 것이다. 데이터베이스 스레드는 콜백 함수가 무엇을 수행하는지 관심이 없을 뿐만 아니라, 관심을 가져서도 안 된다. 분명히 호출자만 데이터베이스 결과를 처리하는 방법을 알고 있으며, 호출자가 처리해야 할 작업은 사용자 요청에 따라 매우 다양할 수 있다. 하지만 이런 작업들은 모두 콜백 함수에 담아 데이터베이스 스레드에 전달할 수 있다. 데이터베이스 스레드가 자체적으로 함수를 정의하면 사용자 요청에 유연하게 대응하기 어렵지만, 이를 콜백 함수를 이용해 극복할 수 있는 것이다. 

주 스레드가 사용자 요청을 처리하는 작업과, 데이터베이스 스레드가 데이터베이스를 처리하는 작업을 동시에 진행할 수 있으며, 이런 설계는 시스템 리소스를 더 많이 최대한 활용할 수 있어서 요청 처리 속도가 훨씬 빨라진다. 사용자 입장에서 볼 때도 시스템 응답 속도가 더 빨라진다. 이것이 바로 비동기가 가지는 높은 효율성이다. 하지만 ㅂ비동기 프로그래밍은 동기 프로그래밍보다 이해하기 쉽지 않으며, 시스템 유지 보수 측면에서도 동기 프로그래밍에 비할 바가 못된다.

2) 두번째 상황: 주 스레드가 데이터베이스 작업 결과에 관심을 가질 때.
데이터베이스 스레드는 알림 작동 방식을 이용해서 작업 결과를 주 스레드로 전송해야 한다. 주 스레드는 메시지를 수신하면, 이전 사용자 요청의 후반부를 계속 처리한다. 이 경우 데이터베이스 스레드가 유후 상태라는 점을 제외하면, 주 스레드에 '유후 시간'이 없다. 이 방식은 첫 번째 상황에서의 비동기 호출만큼 극단적으로 효율적인지는 않지만, 동기 호출에 비하면 여전히 효율적이다. 

물론 모든 비동기 호출이 반드시 동기 호출보다 더 효율적인 것은 아니기 때문에, 구체적인 상황에 따라 분석해야 한다. 