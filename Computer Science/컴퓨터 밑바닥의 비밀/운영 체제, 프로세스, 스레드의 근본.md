# CPU

- CPU는 메모리에서 명령어(instruction) 하나를 가져와서(dispatch) 실행(execute)한 후 다음에 실행할 명령어를 가져온다. (명령어 인출 - 명령어 실행 - 명령어 인출...)
- 프로그램 카운터(program counter): 용량은 작지만 속도는 매우 빠른 일종의 메모리. CPU 내부에 있는 일종의 레지스터(register)로, CPU가 다음에 실행할 메모리에 저장된 명령어의 주소를 가지고 있다. 
- PC Register가 저장하는 주소는 기본적으로 1씩 자동으로 증가한다. 대부분 CPU가 주소를 하나씩 증가시키면서 차례대로 명령어를 실행하기 때문에 순차적인 동작 방식은 일리가 있다. 하지만 if else 또는 함수 호출 같은 명령어를 만나면 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 PC 레지스터 값을 동적으로 변경한다. 이런 방식으로 CPU는 실행해야 할 명령어로 정확하게 점프한다. 
- 프로그래머가 작성한 소스 파일 -(컴파일러)> 디스크의 실행 파일 -(메모리에 적재)> 메모리에 저장된 명령어 -> PC Register에 실행할 메모리 주소 저장 -> CPU가 가져와 실행
- 최초의 PC Register 값 설정: 프로그램이 시작되면 먼저 main 함수에 대응하는 첫 번째 기계 명령어를 찾고, 이어서 그 메모리 주소를 PC 레지스터에 기록한다. 물론 main 함수를 실제로 실행하기 전에 일부 레지스터의 초기화처럼 별도의 초기화 과정이 진행된다.

### CPU에서 운영 체제까지
- CPU가 프로그램을 실행하게 하려면 디스크에 저장된 실행 파일을 수동으로 메모리에 복사한 다음 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다. 하지만 이렇게 하면 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)을 찾아 PC register를 설정하는 등을 작업을 개발자가 직접 해야 한다. 이렇게 수동적으로 프로그램을 실행하면 단점이 있는데: 한 번에 하나의 프로그램만 실행할 수 있다; 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없다 - 네트워크 통신하려면 TCP/IP 스택 소스 코드에도 연결해야 한다; 운영체제가 제공하는 라이브러리 지원을 받을 수 없어서 직접 다 만들어야 한다; 상호 작용 인터페이스(interactive interface)를 원하면 직접 다 구현해야 한다. 
- CPU는 한 번에 한 가지 일만 할 수 있기 때문에, 프로그램 A의 기계 명령어를 실행하거나 프로그램 B의 기계 명령어를 실행하는 것 중 하나만 할 수 있다. 때문에 프로그램 A, B가 동시에 실행되는 것처럼 보이게 하려면 CPU의 전환 빈도를 충분히 빠르게 하면 된다. 
- 이때 CPU가 전환을 하려면 어떤 기계 명령어를 실행했는지와 CPU 내부의 기타 레지스터 값 등 상태 값에 대한 정보를 저장해두고 있어야 하는데, 이때 저장되는 상태를 상황 정보(context)라고 하고, 프로그램이 이 실행 중인 모든 정보를 기록할 수 있는 이런 형태의 구조체를 가지게 되면 프로세스(process)가 된다. 
- 따라서 모든 프로그램은 실행된 후에 프로세스 형태로 관리되고, 원하는 대로 일시 중지하거나 다시 시작할 수 있다. 
- 운영 체제(operating system)은 프로그램을 자동으로 적재해 주는 적재 도구와 멀티태스킹을 실현해주는 프로세스 관리 도구 등 여러 가지 기반 기능의 프로그램을 모아 둔 프로그램이다. 운영체제가 탄생함으로써 프로그래머는 더 이상 실행 파일을 수동으로 적재하거나 프로그램을 수동으로 유지 관리할 필요가 없어졌다. 운영 체제가 모든 것을 뒤(background)에서 처리해 주기 때문에, 시스템에서 실제로 실행 중인 타 프로세스가 몇 개인지, CPU가 몇 개인지, 물리 메모리의 용량이 얼마인지 신경 쓰지 않고 간단하게 내가 지금 사용하는 프로그램이 CPU와 표준 크기의 메모리를 독점하고 있다고 가정할 수 있다. 

### 프로세스는 훌륭하지만 아직 불편하다
- 운영 체제의 가상 메모리는 각각의 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 한다.
- 표준적인 메모리 공간, 즉, 프로세스 주소 공간(process address space)은 네 영역으로 나눌 수 있다:
1) 코드 영역(code segment): 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
2) 데이터 영역(data segment): 전역 변수 등이 저장된다.
3) 힙 영역(heap segment): malloc 함수가 요청을 반환한 메모리가 여기에 할당된다.
4) 스택 영역(stack segment): 함수의 실행 시간 스택이다.
- 만약 함수A와 함수B를 실행시키고 두 개의 함수의 결과를 합치는 하나의 실행 흐름(flow of execution)에서 총 실행 속도를 높이려면 프로세스A와 프로세스B를 생성해서 각각 funA와 funB의 결과를 얻은 후에 프로세스B의 결과를 프로세스A에 전달해서 값 두 개를 더하는 것인데, 이는 다중 프로세스 프로그래밍(multi-process programming)의 프로세스 간 통신(inter-process communication)이다. 그런데 이 다중 프로세스 프로그래밍에는 단점이 있다: 1) 프로세스를 생성할 때 드는 비교적 큰 부담(overhead), 그리고 2) 프로세스마다 자체적인 주소 공간을 가지고 있기에 프로세스 간 통신은 프로그래밍하기에 복잡하다는 점. 


### 프로세스에서 스레드로
- 프로스의 주소 공간에는 CPU가 실행되는 기계 명령어와, 함수가 실행될 때 스택 정보가 저장된다. 그리고 프로세스를 실행하려면 main 함수의 첫 번째 기계 명령어 주소를 PC 레지스터에 기록해야 한다. 이 과정을 거치면 명령어 실행 흐름이 생성된다.
- PC 레지스터가 main 함수를 가르키게 할 수 있듯이, 다른 함수를 가리키게 할 수 있으며, 이를 통해 새로운 실행 흐름을 형성할 수 있다. 이런 실행 흐름은 동일한 프로세스 주소 공간을 공유하므로, 더 이상 프로세스 간 통신이 필요하지 않다. 즉, CPU 여러 개가 동일한 프로세스의 기계 명령어를 실행하도록 할 수 있다. 다시 말해, 하나의 프로세스에 진입 함수가 두 개 이상 있을 수 있고, 하나의 프로세스에 속한 기계 명령어를 CPU 여러 개에서 동시에 실행할 수 있다. 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 명령어를 동시에 실행할 수 있는 것이다.
- 하나의 프로세스 안에 여러 실행 흐름이 존재할 수 있고, 이 실행 흐름을 스레드(thread)라고 한다. 
- 스레드는 동일한 프로세스 주소 공간에 속해 있기 때문에 자신이 속한 프로세스의 주소 공간을 공유하며, 따라서 통신이라는 개념이 필요가 없다. 이는 스레드가 프로세스보다 훨씬 가볍고 생성 속도가 빠르다: 때문에 스레드를 종종 경량 프로세스(light-weight process)라고 한다. 
- 프로세스를 시작하고 스레드 여러 개를 생성하기만 함녀 다중 코어를 이용하여 모든 CPU를 최대한 활용할 수 있고, 이것이 바로 고성능과 높은 동시성의 기초가 된다. 하지만 다중 코어가 있어야만 다중 스레드(multi-threading)을 사용할 수 있는 것은 아니며, 단일 코어인 상황에서도 스레드 여러 개를 생성할 수 있다. 스레드가 운영 체제 계층에 구현되며, 코어 개수와는 무관하기 때문이다. 
- CPU가 기계 명령어를 실행할 때 실행 중인 기계 명령어가 어떤 스레드에 속해 있는지 인식하지 못한다. 또 스레드에는 다중 코어를 충분히 활용하는 것 외에도 다른 용도가 있다. 예를 들어서 그래픽 사용자 인터페이스 프로그래밍을 할 때 특정 이벤트를 처리하는 데 많은 시간이 필요하여 응답이 없는 상황을 방지하고자 해당 이벤트를 처리하는 별도의 스레드를 생성할 수 있다. 
- 각 스레드가 프로세스의 메모리 주소 공간을 공유하기 때문에, 자연스럽게 스레드 간 '통신'을 위한 운영 체제의 지원도 필요하지 않다. 하지만 동시에 다중 스레드가 공유 리소스에 접근할 때 오류가 발생할 수 있다 ㅡ CPU가 명령어를 실행할 때 스레드를 전혀 고려하지 않기 때문이다. 따라서 프로그래머는 상호 배제(mutual exclusion)과 동기화(synchronization)을 이용하여 다중 스레드 공유 리소스, 문제를 명시적으로 직접 해결해야 한다. 

---
## CPU와 PC Register, 그리고 Thread
CPU의 스레드 스케줄링과 컨텍스트 스위칭

스레드 스케줄링 (Thread Scheduling):
운영 체제의 스케줄러는 CPU의 사용을 여러 스레드 사이에 나누어 할당합니다. 이 과정에서 각 스레드가 실행될 때 CPU를 사용할 수 있도록 합니다.
CPU는 특정 시간 동안 하나의 스레드를 실행하고, 그 후 다른 스레드를 실행하는 방식으로 스레드 간에 CPU 시간을 분배합니다.

컨텍스트 스위칭 (Context Switching):
컨텍스트 스위칭은 CPU가 현재 실행 중인 스레드의 상태(레지스터 값, 프로그램 카운터(PC), 스택 포인터 등)를 저장하고, 다음에 실행할 스레드의 상태를 불러오는 과정입니다.
스레드의 상태는 해당 스레드가 다시 실행될 때 이어서 작업을 수행할 수 있도록, 운영 체제가 메모리에 저장합니다.
이 과정은 매우 빠르게 일어나기 때문에, 사용자나 프로그램은 여러 스레드가 동시에 실행되는 것처럼 보이게 됩니다. 하지만 실제로는 CPU가 한 스레드에서 다른 스레드로 매우 빠르게 전환하면서 실행을 관리하고 있는 것입니다.

PC 레지스터와 스레드:
PC 레지스터는 현재 실행 중인 스레드가 다음에 실행할 명령어의 주소를 저장합니다.
스레드가 실행될 때, CPU는 해당 스레드의 PC 레지스터를 읽고 다음 명령어를 실행합니다.
컨텍스트 스위칭 시, 현재 스레드의 PC 레지스터 값을 저장하고, 다음에 실행할 스레드의 PC 레지스터 값을 복원함으로써 실행 흐름을 이어갑니다.

요약
CPU는 한 번에 하나의 스레드만 실행할 수 있습니다.
여러 스레드가 동시에 실행되는 것처럼 보이기 위해, CPU는 매우 빠른 속도로 여러 스레드 간의 컨텍스트를 스위칭합니다.
이 스위칭 과정에서 각 스레드의 상태(특히 PC 레지스터 값 등)를 저장하고 복원하여, 각 스레드가 마치 동시에 실행되는 것처럼 느껴지게 합니다.
결과적으로, 여러 스레드가 CPU를 공유하면서 작업을 수행하게 되며, 사용자에게는 여러 스레드가 동시에 실행되는 것처럼 보이게 됩니다.

이 방식 덕분에 단일 CPU 시스템에서도 여러 스레드가 병렬로 작업을 수행하는 것처럼 보이게 할 수 있습니다.

스레드가 여러 실행 흐름을 가질 수 있다는 것은, 각 스레드가 독립적인 PC 레지스터(Program Counter) 값을 가지고 있다는 의미입니다. 이 PC 레지스터는 현재 스레드가 실행 중인 명령어(또는 함수)의 메모리 주소를 가리키고 있습니다. 따라서, 스레드마다 PC 레지스터가 가리키는 위치가 다를 수 있으며, 이로 인해 각 스레드가 서로 다른 코드를 실행할 수 있게 됩니다.

요약하자면:

•PC 레지스터의 역할: 각 스레드는 고유한 PC 레지스터 값을 가지고 있으며, 이 값은 해당 스레드가 현재 실행 중인 명령어 또는 함수의 위치를 가리킵니다.
•다양한 실행 흐름: 다중 스레드 환경에서는 각 스레드가 서로 다른 PC 레지스터 값을 가질 수 있으므로, 서로 다른 함수나 코드의 부분을 동시에 실행할 수 있습니다.
•동시성의 구현: 이로 인해, 다중 스레드 프로그램은 여러 실행 흐름을 가지게 되며, 이는 마치 여러 작업이 동시에 이루어지는 것처럼 보이게 합니다.

따라서, 여러 스레드를 사용하여 다양한 실행 흐름을 구현할 수 있다는 것은 곧 여러 PC 레지스터가 서로 다른 위치를 가리키면서 독립적으로 작업을 수행할 수 있다는 것을 의미합니다.


**실행 흐름(Execution Flow)** 은 컴퓨터 프로그램이 실행되는 동안 명령어들이 순차적으로 처리되는 과정을 의미합니다. 실행 흐름은 프로그램의 논리적인 진행 경로로, 프로그램의 코드가 시작부터 끝까지 어떻게 실행되는지를 나타냅니다.

구체적인 설명

1.	순차적인 실행:
- 대부분의 프로그램은 순차적으로 실행됩니다. 즉, 코드의 첫 번째 줄부터 마지막 줄까지 차례대로 실행됩니다. 이 순차적인 흐름이 바로 실행 흐름입니다.
- 예를 들어, main() 함수에서 시작된 프로그램은 첫 번째 명령어부터 차례로 실행되면서 프로그램의 상태를 변화시킵니다.
2. 제어 구조와 실행 흐름:
- 조건문(If-Else): 조건에 따라 실행 흐름이 다른 경로로 분기됩니다. 예를 들어, if 조건이 참이면 한 블록의 코드가 실행되고, 거짓이면 다른 블록이 실행됩니다.
- 반복문(For, While): 특정 조건이 만족될 때까지 코드 블록을 반복하여 실행하는 제어 구조입니다. 반복문의 조건이 충족될 때마다 동일한 코드가 반복 실행되며, 이 역시 실행 흐름의 일부입니다.
- 함수 호출: 프로그램이 함수나 메서드를 호출할 때, 실행 흐름이 해당 함수로 이동한 뒤, 함수의 실행이 끝나면 원래 호출한 위치로 돌아옵니다. 이 과정 역시 실행 흐름을 정의합니다.
3. 다중 실행 흐름:
- 스레드: 다중 스레드를 사용하는 프로그램에서는 여러 실행 흐름이 동시에 존재할 수 있습니다. 각 스레드는 독립적인 실행 흐름을 가지며, 서로 다른 코드 조각을 동시에 실행할 수 있습니다.
- 비동기 처리: 비동기 작업은 메인 실행 흐름과는 별도로 실행되는 흐름을 만듭니다. 예를 들어, 네트워크 요청을 보내고 그 응답을 기다리는 동안, 메인 실행 흐름은 중단되지 않고 다른 작업을 계속 수행할 수 있습니다.
- 실행 흐름의 제어:
프로그램에서 실행 흐름을 제어하는 것은 매우 중요합니다. 이는 프로그램의 논리적 구조를 정의하고, 다양한 조건과 상황에 맞게 코드가 실행되도록 합니다.
실행 흐름을 제어하지 않으면 프로그램이 예상치 못한 동작을 할 수 있으며, 특히 다중 스레드 환경에서는 동시성 문제로 인해 실행 흐름의 정확한 제어가 필요합니다.
---

### 다중 스레드와 메모리 구조
- CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행시킬 수 있다. 
- 함수가 실행될 때 필요한 정보는 함수의 매개변수(parameter), 지역 변수, 반환 주소(return address) 등이 있다. 이런 정보는 스택 프레임(stack frame)에 저장되며, 모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임(runtime stack frame)을 가진다. 함수가 호출되고 반환될 때마다 이 스택 프레임은 후입선출(last in first out) 순서로 증가하거나 감소하며, 이런 스택 프레임의 증감이 프로세스 주소 공간에서 스택 영역을 형성한다. 
- 스레드가 등장하며 하나의 프로세스에 실행 진입점(execution entry point)가 여럿 존재할 수 있게 되었고, 동시에 실행 흐름도 여러 개 존재할 수 있게 되었다. 실행 흐름이 하나뿐인 프로세스는 실행 시 정보를 저장하는 스택 영역이 하나만 있으면 되지만, 실행 흐름을 여러 개를 가지는 멀티 스레드 프로세스는 각 흐름이 실행될 때 정보를 저장하기 위해 스택 영역이 여러 개 필요하다. 프로세스의 주소 공간에 각 스레드를 위한 스택 영역이 별도로 있어야 한다. 즉, 모든 스레드는 각자 자신만의 스택 영역을 가지는데, 스레드가 이를 인지하고 있는 것이 중요하다. 스레드를 생성하면 프로세스의 메모리 공간이 소모된다는 점도 주의할 필요가 있다. 

---
* 함수의 스택 프레임: 함수가 호출될 때마다 스택에 할당되는 메모리 블록입니다. 이 프레임에는 함수의 매개변수, 지역 변수, 리턴 주소 등이 저장됩니다.
* 실행 시간 스택 프레임: 이 용어는 함수 호출 시 생성된 일련의 스택 프레임을 말합니다. 스레드는 자신의 실행 흐름을 유지하기 위해 여러 함수 호출을 거치며, 이때 스택 프레임들이 연속적으로 쌓이게 됩니다.
* 스레드와 스택 프레임의 연관성: 각 스레드는 자신만의 스택 영역을 가지고 있으며, 이 스택 영역에 각 함수 호출 시마다 스택 프레임이 쌓입니다. 스레드가 함수 호출을 할 때마다 스택에 새로운 프레임이 추가되고, 함수가 종료되면 해당 프레임이 제거됩니다. 이러한 과정을 통해 스레드는 자신의 실행 흐름을 추적하고, 독립적인 작업을 수행할 수 있습니다.
* 스레드가 독립적으로 작업을 수행하기 위해서는 자신만의 메모리 공간이 필요하며, 특히 함수 호출 및 지역 변수 저장을 위해 스택(Stack) 영역이 필수적입니다. 스택은 LIFO(Last In, First Out) 방식으로 작동하며, 함수 호출 시 함수의 매개변수, 리턴 주소, 지역 변수를 저장하고, 함수가 종료되면 이 정보를 스택에서 제거합니다.

스레드가 독립적인 스택 영역을 가져야 하는 가장 큰 이유는 스레드 간의 데이터 충돌을 방지하고 독립적인 실행 흐름을 유지하기 위해서입니다. 좀 더 구체적으로 설명하자면:

1. 지역 변수 충돌 방지

각 스레드는 함수 호출 시 지역 변수를 사용합니다. 이 지역 변수들은 해당 함수의 스택 프레임에 저장됩니다. 만약 스레드들이 스택 영역을 공유한다면, A 스레드의 함수가 사용하는 지역 변수가 B 스레드의 함수에 의해 덮어씌워질 수 있습니다. 이렇게 되면 데이터가 엉키게 되고, 예기치 않은 결과가 발생할 수 있습니다. 독립적인 스택 영역이 있으면, 각 스레드는 자신만의 지역 변수를 안전하게 관리할 수 있습니다.

2. 함수 호출 및 리턴 주소 관리

함수가 호출되면 현재 실행 위치를 저장하고 새로운 함수로 이동합니다. 이때 함수의 리턴 주소가 스택에 저장됩니다. 만약 스레드들이 스택을 공유한다면, 한 스레드가 다른 스레드의 리턴 주소를 덮어써버릴 수 있어, 함수 호출이 끝난 후 잘못된 위치로 돌아갈 위험이 있습니다. 독립적인 스택이 있으면, 각 스레드는 자신의 함수 호출과 리턴 주소를 안전하게 관리할 수 있습니다.

3. 스택 오염 방지

한 스레드가 스택에서 데이터를 기록하거나 삭제하는 동안, 다른 스레드가 같은 스택에 접근하면 데이터 오염이 발생할 수 있습니다. 이러한 오염은 프로그램의 비정상 종료나 잘못된 동작을 초래할 수 있습니다. 독립적인 스택은 이런 문제를 방지합니다.

4. 디버깅과 유지보수 용이

스레드가 독립적인 스택을 갖고 있으면, 각 스레드의 실행 상태를 개별적으로 추적하고 관리하기가 더 쉬워집니다. 이는 디버깅이나 성능 최적화 작업에서 큰 장점을 제공합니다.

결론적으로, 스레드가 독립적인 스택 영역을 가져야 하는 이유는 스레드 간의 데이터 간섭을 방지하고, 각 스레드가 독립적으로 안전하게 실행될 수 있도록 보장하기 위해서입니다. 이로 인해 멀티스레드 환경에서의 안정성, 예측 가능성, 그리고 성능이 보장됩니다.

----
