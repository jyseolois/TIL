# 높은 동시성과 고성능을 갖춘 서버 구현
수만 개의 사용자 요청을 동시에 처리해 주는 서버의 비밀은 무엇일까?

## 다중 프로세스
- 가장 먼저 출현한 기술은 가장 간단한 형태의 병행 처리 방식의 일종인 다중 프로세스를 사용하는 것이었다. 예를 들어서 리눅스 세계에서는 fork 방식을 이용해서 여러 자식 프로세스를 생성할 수 있다. 부모 프로세스가 사용자 요청을 먼저 수신하고, 자식 프로세스를 생성해서 해당 사용자 요청을 처리하도록 한다. 모든 요청에는 각각 대응하는 프로세스(process-per-connection)이 있다. 
- 이 방식의 장점은 다음과 같다: 1) 프로그래밍이 간단하여 매우 이해하기 쉽다 2) 개별 프로세스의 주소 공간은 서로 격리되어 있기 때문에, 하나의 프로세스에 문제가 발생하여 강제 종료되더라도, 다른 프로세스에는 영향을 미치지 않는다. 3) 다중 코어 리소스를 최대한 활용할 수 있다. 
- 하지만 그만큼 단점이 존재한다: 1) 각 프로세스의 주소 공간이 서로 격리되어 있다는 것이 장점이지만, 반대로 이는 단점이 될 수도 있다. 프로세스 간에 서로 통신이 필요할 때 난이도가 올라가며, 프로세스의 통신 작동 방식을 사용해야 한다. 2) 프로세스를 생성할 때 부담이 상대적으로 크고, 프로세스의 빈번한 생성과 종료는 의심의 여지없이 시스템 부담을 증가시킨다.  

## 다중 스레드
- 장점: 1) 스레드는 프로세스 주소 공간을 공유하기 때문에, 스레드 간 통신을 위해 별도의 통신 작동 방식을 사용할 필요가 없다. 2) 스레드 안전이 보장된다는 전제 하에 메모리를 직접 읽어서 데이터를 얻을 수 있다. 3) 매우 가벼울 뿐만 아니라, 생성과 종료에 드는 부담이 프로세스에 비해 적다. 4) 각 요청에 대응하는 스레드(thread-per-connection)을 생성할 수 있으며, 설령 파일 읽기와 같은 입출력 작업으로 스레드 중 일부가 블로킹되어 일시 중지되더라도, 다른 스레드에는 영향을 미치지 않는다.
- 단점: 1) 스레드는 프로세스 주소 공간을 공유하기 때문에 스레드 간 통신에 있어 편리함을 제공하는 한편, 그와 동시에 수많은 문제를 일으키기도 한다. 스레드는 서로 같은 주소 공간을 공유하기 때문에 하나의 스레드에 문제가 발생하여 강제종료 되면, 같은 프로세스 공유하는 모든 스레드와 프로세스가 한꺼번에 종료된다. 2) 이런 공유 주소 공간에는 여러 스레드 기반의 실행 흐름 작동 방식이 존재할 수 있는 반면에, 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸 수 없다는 부작용이 있다. 공유 데이터의 주소를 동시에 쓰려고 하면 스레드 안전 문제가 발생하므로, 반드시 동기화 시 상호 배제와 같은 작동 방식을 사용해야 한다. 더군다나 교착 상태처럼 일련의 문제를 일으킬 수 있어서, 다중 스레드가 일으키는 이런 문제를 해결하는 데 프로그래머의 귀중한 시간 중 상당 부분을 할애해야 한다.
- 하지만 다중 프로세스와 비교할 때 여전히 스레드는 훨씬 유리하다. 사용자 규모가 크지 않은 경우 다중 스레드로도 충분히 처리할 수 있다. 하지만 동시에 클라이언트 연결 1만개를 처리하는 네트워크 소켓 최적화 문제(C10K 문제)에 따르면, 동시 요청 수가 매우 많을 때는 다중 스레드만으로 감당하기가 어렵다.
- 스레드를 생성할 때 발생하는 부담은 프로세스를 생성할 때에 비해서는 적지만, 부담 자체가 아예 없는 것은 아니다. 따라서 초당 수만 개에서 수십만 개에 달하는 요청을 처리해야 하는 높은 동시성을 가지는 서버의 경우, 요청에 따라 스레드 수 수만 개 이상을 생성하면 과도한 메모리 소모나 스레드로 전환할 때의 성능 손실 등 성능 문제가 발생할 수 있다. 

## 이벤트 순환과 이벤트 구동 
프로세스와 스레드 외에도 병행 프로그래밍을 위한 기술이 있는데, 이벤트 기반의 동시성(event-based concurrency)을 이용한 이벤트 기반 프로그래밍(event-driven programming)이다. 

이벤트 기반 프로그래밍 기술에는 두 가지 요소가 필요하다.
1. 이벤트(event): 예를 들어서 입출력 이벤트 - 네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등이 이벤트에 해당한다.
2. 이벤트를 처리하는 함수: 일반적으로 이벤트 핸들러(event handler)라고 한다. 

이벤트 기반 프로그래밍에서는 이벤트가 도착할 때까지 기다렸다가 이벤트가 도착하면 이벤트 유형을 확인하고, 해당 유형에 대응하는 이벤트 처리 함수인 이벤트 핸들러를 찾은 후 직접 이벤트 핸들러를 호출하면 된다. 

이벤트는 계속 발생할 수 있다. 서버에서 이벤트는 바로 사용자 요청이며, 이 이벤트를 계속 수신하고 처리해야 한다. 따라서 while 또는 for 반복문을 사용해서 반복적으로 처리할 필요가 있다. 이 반복을 이벤트 순환(event loop)이라고 한다. 

```aiignore
while (true) {
    event = getEvnet(); // 이벤트 수신 대기
    handler(event); // 이벤트 처리 
}
```

이벤트 순환에서 수행해야 하는 작업은 이토록 간단하다. 이벤트가 도착할 때까지 기다렸다가, 대응하는 이벤트 핸들러만 호출하면 된다.

하지만 여전히 해결해야 할 두 가지 문제가 남아 있다.
1. 이벤트 소스에 관한 문제: getEvent() 같은 함수 하나로 어떻게 여러 이벤트를 가져올 수 있을까?
2. 이벤트를 처리하는 handler 함수가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 할까?

첫 번째 문제에 대한 서버 프로그래밍 분야의 해결책은 바로 입출력 다중화 (input/output multiplexing) 기술이다.

## 이벤트 소스와 입출력 다중화
리눅스와 유닉스(UNIX)에서는 모든 것이 다 파일로 취급된다. 프로그램은 모두 파일 서술자(file descriptor)을 사용해서 입출력 작업을 실행하며, 소켓(socket)도 예외는 아니다. 그렇다면 동시에 파일 서술자 여러 개를 처리하려면 어떻게 해야 할까?

사용자 연결이 열 개고, 이에 대응하는 소켓 서술자가 열 개 있는 서버가 데이터를 수신하려고 대기 중이라고 가정한다면, 가장 간단한 처리 방법은 다음과 같다.

```aiignore
recv(fd1, buf1);
recv(fd2, buf2);
recv(fd3, buf3);
recv(fd4, buf4);
```

하지만 문제가 있다. 첫 번째 사용자가 데이터를 보내지 않는 한 recv(fd1, buf1) 코드는 반환되지 않으므로, 서버가 두 번째 사용자의 데이터를 수신하고 처리할 기회가 사라진다. 당연하게도 각 서술자를 무턱대고 순차적으로 처리하는 것은 좋은 생각이 아니다. 더 나은 접근 방식은, 운영 체제에 다음 내용을 전달하는 작동 방식을 사용하는 것이다. 더 나은 방식은 운영 체제에 다음 내용을 전달하는 작동 방식을 사용하는 것이다. 간단히 말해, '저 대신 소캣 서술자 열 개를 감시하고 있다가, 데이터가 들어오면 저에게 알려주세요'라고 하는 것이다. 이런 작동 방식을 입출력 다중화라고 하며, 이와 같은 작동 방식 중 리눅스 세게에서 제일 유명한 것이 바로 epoll이다.

```aiignore
// epoll 생성
epoll_fd = epoll_create();

// 서술자를 epoll이 처리하도록 지정
Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4...);

while (1) {
    int n = epoll_wait(epoll_fd);
    for (i = 0; i < n; i++>) {
        // 특정 이벤트 처리
    }
}
```
이렇게 epoll은 이벤트 순환을 위해 탄생했다. 여기에서 epoll_wait()는 앞서 보았던 의사 코드의 getEvent 함수와 역할이 동일하므로, 입출력 다중화 기술이 이벤트 순환의 엔진이 되어 지속적으로 다양한 이벤트를 제공한다.

즉, 입출력 다중화는, 여러 개의 이벤트 소스를 동시에 관리하고 처리하는 기술이다. 간단히 말해, 프로그램이 “한 번에 하나씩” 이벤트를 처리하는 것이 아니라, 여러 이벤트를 동시에 감시하고 그 중에서 실제 데이터가 들어온 이벤트만 처리할 수 있게 해 준다.