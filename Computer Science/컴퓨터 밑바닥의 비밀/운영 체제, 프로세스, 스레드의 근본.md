# CPU

- CPU는 메모리에서 명령어(instruction) 하나를 가져와서(dispatch) 실행(execute)한 후 다음에 실행할 명령어를 가져온다. (명령어 인출 - 명령어 실행 - 명령어 인출...)
- 프로그램 카운터(program counter): 용량은 작지만 속도는 매우 빠른 일종의 메모리. CPU 내부에 있는 일종의 레지스터(register)로, CPU가 다음에 실행할 메모리에 저장된 명령어의 주소를 가지고 있다. 
- PC Register가 저장하는 주소는 기본적으로 1씩 자동으로 증가한다. 대부분 CPU가 주소를 하나씩 증가시키면서 차례대로 명령어를 실행하기 때문에 순차적인 동작 방식은 일리가 있다. 하지만 if else 또는 함수 호출 같은 명령어를 만나면 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 PC 레지스터 값을 동적으로 변경한다. 이런 방식으로 CPU는 실행해야 할 명령어로 정확하게 점프한다. 
- 프로그래머가 작성한 소스 파일 -(컴파일러)> 디스크의 실행 파일 -(메모리에 적재)> 메모리에 저장된 명령어 -> PC Register에 실행할 메모리 주소 저장 -> CPU가 가져와 실행
- 최초의 PC Register 값 설정: 프로그램이 시작되면 먼저 main 함수에 대응하는 첫 번째 기계 명령어를 찾고, 이어서 그 메모리 주소를 PC 레지스터에 기록한다. 물론 main 함수를 실제로 실행하기 전에 일부 레지스터의 초기화처럼 별도의 초기화 과정이 진행된다.

### CPU에서 운영 체제까지
- CPU가 프로그램을 실행하게 하려면 디스크에 저장된 실행 파일을 수동으로 메모리에 복사한 다음 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다. 하지만 이렇게 하면 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)을 찾아 PC register를 설정하는 등을 작업을 개발자가 직접 해야 한다. 이렇게 수동적으로 프로그램을 실행하면 단점이 있는데: 한 번에 하나의 프로그램만 실행할 수 있다; 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없다 - 네트워크 통신하려면 TCP/IP 스택 소스 코드에도 연결해야 한다; 운영체제가 제공하는 라이브러리 지원을 받을 수 없어서 직접 다 만들어야 한다; 상호 작용 인터페이스(interactive interface)를 원하면 직접 다 구현해야 한다. 
- CPU는 한 번에 한 가지 일만 할 수 있기 때문에, 프로그램 A의 기계 명령어를 실행하거나 프로그램 B의 기계 명령어를 실행하는 것 중 하나만 할 수 있다. 때문에 프로그램 A, B가 동시에 실행되는 것처럼 보이게 하려면 CPU의 전환 빈도를 충분히 빠르게 하면 된다. 
- 이때 CPU가 전환을 하려면 어떤 기계 명령어를 실행했는지와 CPU 내부의 기타 레지스터 값 등 상태 값에 대한 정보를 저장해두고 있어야 하는데, 이때 저장되는 상태를 상황 정보(context)라고 하고, 프로그램이 이 실행 중인 모든 정보를 기록할 수 있는 이런 형태의 구조체를 가지게 되면 프로세스(process)가 된다. 
- 따라서 모든 프로그램은 실행된 후에 프로세스 형태로 관리되고, 원하는 대로 일시 중지하거나 다시 시작할 수 있다. 
- 운영 체제(operating system)은 프로그램을 자동으로 적재해 주는 적재 도구와 멀티태스킹을 실현해주는 프로세스 관리 도구 등 여러 가지 기반 기능의 프로그램을 모아 둔 프로그램이다. 운영체제가 탄생함으로써 프로그래머는 더 이상 실행 파일을 수동으로 적재하거나 프로그램을 수동으로 유지 관리할 필요가 없어졌다. 운영 체제가 모든 것을 뒤(background)에서 처리해 주기 때문에, 시스템에서 실제로 실행 중인 타 프로세스가 몇 개인지, CPU가 몇 개인지, 물리 메모리의 용량이 얼마인지 신경 쓰지 않고 간단하게 내가 지금 사용하는 프로그램이 CPU와 표준 크기의 메모리를 독점하고 있다고 가정할 수 있다. 

### 프로세스는 훌륭하지만 아직 불편하다
- 운영 체제의 가상 메모리는 각각의 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 한다.
- 표준적인 메모리 공간, 즉, 프로세스 주소 공간(process address space)은 네 영역으로 나눌 수 있다:
1) 코드 영역(code segment): 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
2) 데이터 영역(data segment): 전역 변수 등이 저장된다.
3) 힙 영역(heap segment): malloc 함수가 요청을 반환한 메모리가 여기에 할당된다.
4) 스택 영역(stack segment): 함수의 실행 시간 스택이다.
- 만약 함수A와 함수B를 실행시키고 두 개의 함수의 결과를 합치는 하나의 실행 흐름(flow of execution)에서 총 실행 속도를 높이려면 프로세스A와 프로세스B를 생성해서 각각 funA와 funB의 결과를 얻은 후에 프로세스B의 결과를 프로세스A에 전달해서 값 두 개를 더하는 것인데, 이는 다중 프로세스 프로그래밍(multi-process programming)의 프로세스 간 통신(inter-process communication)이다. 그런데 이 다중 프로세스 프로그래밍에는 단점이 있다: 1) 프로세스를 생성할 때 드는 비교적 큰 부담(overhead), 그리고 2) 프로세스마다 자체적인 주소 공간을 가지고 있기에 프로세스 간 통신은 프로그래밍하기에 복잡하다는 점. 