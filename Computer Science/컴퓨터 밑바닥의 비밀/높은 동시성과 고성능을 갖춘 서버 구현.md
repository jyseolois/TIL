# 높은 동시성과 고성능을 갖춘 서버 구현
수만 개의 사용자 요청을 동시에 처리해 주는 서버의 비밀은 무엇일까?

## 다중 프로세스
- 가장 먼저 출현한 기술은 가장 간단한 형태의 병행 처리 방식의 일종인 다중 프로세스를 사용하는 것이었다. 예를 들어서 리눅스 세계에서는 fork 방식을 이용해서 여러 자식 프로세스를 생성할 수 있다. 부모 프로세스가 사용자 요청을 먼저 수신하고, 자식 프로세스를 생성해서 해당 사용자 요청을 처리하도록 한다. 모든 요청에는 각각 대응하는 프로세스(process-per-connection)이 있다. 
- 이 방식의 장점은 다음과 같다: 1) 프로그래밍이 간단하여 매우 이해하기 쉽다 2) 개별 프로세스의 주소 공간은 서로 격리되어 있기 때문에, 하나의 프로세스에 문제가 발생하여 강제 종료되더라도, 다른 프로세스에는 영향을 미치지 않는다. 3) 다중 코어 리소스를 최대한 활용할 수 있다. 
- 하지만 그만큼 단점이 존재한다: 1) 각 프로세스의 주소 공간이 서로 격리되어 있다는 것이 장점이지만, 반대로 이는 단점이 될 수도 있다. 프로세스 간에 서로 통신이 필요할 때 난이도가 올라가며, 프로세스의 통신 작동 방식을 사용해야 한다. 2) 프로세스를 생성할 때 부담이 상대적으로 크고, 프로세스의 빈번한 생성과 종료는 의심의 여지없이 시스템 부담을 증가시킨다.  

## 다중 스레드
- 장점: 1) 스레드는 프로세스 주소 공간을 공유하기 때문에, 스레드 간 통신을 위해 별도의 통신 작동 방식을 사용할 필요가 없다. 2) 스레드 안전이 보장된다는 전제 하에 메모리를 직접 읽어서 데이터를 얻을 수 있다. 3) 매우 가벼울 뿐만 아니라, 생성과 종료에 드는 부담이 프로세스에 비해 적다. 4) 각 요청에 대응하는 스레드(thread-per-connection)을 생성할 수 있으며, 설령 파일 읽기와 같은 입출력 작업으로 스레드 중 일부가 블로킹되어 일시 중지되더라도, 다른 스레드에는 영향을 미치지 않는다.
- 단점: 1) 스레드는 프로세스 주소 공간을 공유하기 때문에 스레드 간 통신에 있어 편리함을 제공하는 한편, 그와 동시에 수많은 문제를 일으키기도 한다. 스레드는 서로 같은 주소 공간을 공유하기 때문에 하나의 스레드에 문제가 발생하여 강제종료 되면, 같은 프로세스 공유하는 모든 스레드와 프로세스가 한꺼번에 종료된다. 2) 이런 공유 주소 공간에는 여러 스레드 기반의 실행 흐름 작동 방식이 존재할 수 있는 반면에, 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸 수 없다는 부작용이 있다. 공유 데이터의 주소를 동시에 쓰려고 하면 스레드 안전 문제가 발생하므로, 반드시 동기화 시 상호 배제와 같은 작동 방식을 사용해야 한다. 더군다나 교착 상태처럼 일련의 문제를 일으킬 수 있어서, 다중 스레드가 일으키는 이런 문제를 해결하는 데 프로그래머의 귀중한 시간 중 상당 부분을 할애해야 한다.
- 하지만 다중 프로세스와 비교할 때 여전히 스레드는 훨씬 유리하다. 사용자 규모가 크지 않은 경우 다중 스레드로도 충분히 처리할 수 있다. 하지만 동시에 클라이언트 연결 1만개를 처리하는 네트워크 소켓 최적화 문제(C10K 문제)에 따르면, 동시 요청 수가 매우 많을 때는 다중 스레드만으로 감당하기가 어렵다.
- 스레드를 생성할 때 발생하는 부담은 프로세스를 생성할 때에 비해서는 적지만, 부담 자체가 아예 없는 것은 아니다. 따라서 초당 수만 개에서 수십만 개에 달하는 요청을 처리해야 하는 높은 동시성을 가지는 서버의 경우, 요청에 따라 스레드 수 수만 개 이상을 생성하면 과도한 메모리 소모나 스레드로 전환할 때의 성능 손실 등 성능 문제가 발생할 수 있다. 

## 이벤트 순환과 이벤트 구동 
프로세스와 스레드 외에도 병행 프로그래밍을 위한 기술이 있는데, 이벤트 기반의 동시성(event-based concurrency)을 이용한 이벤트 기반 프로그래밍(event-driven programming)이다. 

이벤트 기반 프로그래밍 기술에는 두 가지 요소가 필요하다.
1. 이벤트(event): 예를 들어서 입출력 이벤트 - 네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등이 이벤트에 해당한다.
2. 이벤트를 처리하는 함수: 일반적으로 이벤트 핸들러(event handler)라고 한다. 

이벤트 기반 프로그래밍에서는 이벤트가 도착할 때까지 기다렸다가 이벤트가 도착하면 이벤트 유형을 확인하고, 해당 유형에 대응하는 이벤트 처리 함수인 이벤트 핸들러를 찾은 후 직접 이벤트 핸들러를 호출하면 된다. 

이벤트는 계속 발생할 수 있다. 서버에서 이벤트는 바로 사용자 요청이며, 이 이벤트를 계속 수신하고 처리해야 한다. 따라서 while 또는 for 반복문을 사용해서 반복적으로 처리할 필요가 있다. 이 반복을 이벤트 순환(event loop)이라고 한다. 

```aiignore
while (true) {
    event = getEvnet(); // 이벤트 수신 대기
    handler(event); // 이벤트 처리 
}
```

이벤트 순환에서 수행해야 하는 작업은 이토록 간단하다. 이벤트가 도착할 때까지 기다렸다가, 대응하는 이벤트 핸들러만 호출하면 된다.

하지만 여전히 해결해야 할 두 가지 문제가 남아 있다.
1. 이벤트 소스에 관한 문제: getEvent() 같은 함수 하나로 어떻게 여러 이벤트를 가져올 수 있을까?
2. 이벤트를 처리하는 handler 함수가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 할까?

첫 번째 문제에 대한 서버 프로그래밍 분야의 해결책은 바로 입출력 다중화 (input/output multiplexing) 기술이다.

## 이벤트 소스와 입출력 다중화
리눅스와 유닉스(UNIX)에서는 모든 것이 다 파일로 취급된다. 프로그램은 모두 파일 서술자(file descriptor)을 사용해서 입출력 작업을 실행하며, 소켓(socket)도 예외는 아니다. 그렇다면 동시에 파일 서술자 여러 개를 처리하려면 어떻게 해야 할까?

사용자 연결이 열 개고, 이에 대응하는 소켓 서술자가 열 개 있는 서버가 데이터를 수신하려고 대기 중이라고 가정한다면, 가장 간단한 처리 방법은 다음과 같다.

```aiignore
recv(fd1, buf1);
recv(fd2, buf2);
recv(fd3, buf3);
recv(fd4, buf4);
```

하지만 문제가 있다. 첫 번째 사용자가 데이터를 보내지 않는 한 recv(fd1, buf1) 코드는 반환되지 않으므로, 서버가 두 번째 사용자의 데이터를 수신하고 처리할 기회가 사라진다. 당연하게도 각 서술자를 무턱대고 순차적으로 처리하는 것은 좋은 생각이 아니다. 더 나은 접근 방식은, 운영 체제에 다음 내용을 전달하는 작동 방식을 사용하는 것이다. 더 나은 방식은 운영 체제에 다음 내용을 전달하는 작동 방식을 사용하는 것이다. 간단히 말해, '저 대신 소캣 서술자 열 개를 감시하고 있다가, 데이터가 들어오면 저에게 알려주세요'라고 하는 것이다. 이런 작동 방식을 입출력 다중화라고 하며, 이와 같은 작동 방식 중 리눅스 세게에서 제일 유명한 것이 바로 epoll이다.

```aiignore
// epoll 생성
epoll_fd = epoll_create();

// 서술자를 epoll이 처리하도록 지정
Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4...);

while (1) {
    int n = epoll_wait(epoll_fd);
    for (i = 0; i < n; i++>) {
        // 특정 이벤트 처리
    }
}
```
이렇게 epoll은 이벤트 순환을 위해 탄생했다. 여기에서 epoll_wait()는 앞서 보았던 의사 코드의 getEvent 함수와 역할이 동일하므로, 입출력 다중화 기술이 이벤트 순환의 엔진이 되어 지속적으로 다양한 이벤트를 제공한다.

즉, 입출력 다중화는, 여러 개의 이벤트 소스를 동시에 관리하고 처리하는 기술이다. 간단히 말해, 프로그램이 “한 번에 하나씩” 이벤트를 처리하는 것이 아니라, 여러 이벤트를 동시에 감시하고 그 중에서 실제 데이터가 들어온 이벤트만 처리할 수 있게 해 준다.

## 이벤트 순환과 다중 스레드
상황에 따라, 이벤트를 처리하는 hanlder 함수가 이벤트 순환과 같거나 다른 스레드에서 실행된다.
이벤트 핸들러에 입출력 작업이 전혀 없고, 처리 함수가 간단해서 소요 시간이 매우 짧다면, 이벤트 핸들러와 이벤트 순환을 동일한 스레드에서 실행할 수 있다. 이 경우 요청은 순차적으로 처리되는데, 모든 요청이 단일 스레드에서 순차적으로 처리된다. 하지만 요청을 처리하는 데 시간이 거의 걸리지 않는다는 것을 전제로 하기에 서버는 짧은 시간에도 많은 요청을 처리할 수 있다. 또 요청이 순차적으로 처리되더라도, 사용자 입장에서는 응답이 눈에 띄게 지연된다고 느낄 일은 없을 것이다.

하지만 사용자 요청을 처리하는 데 CPU 시간을 많이 소모한다면 어떻게 해야 할까? 이런 경우에도 여전히 단일 스레드를 사용하고 있다면, 사용자는 시스템 응답이 너무 느리다고 불평할 것이며, 이벤트 순환은 단일 스레드에서 처리되고 있어서 요청 A를 처리하는 사이 요청 B에 응답할 방법이 없다. 따라서 요청의 처리 속도를 높이고, 최신 컴퓨터 시스템의 다중 코어를 최대한 활용하려면 다중 스레드의 도움이 필요하다. 이제 이벤트 핸들러는 더 이상 이벤트 순환과 동일한 스레드에서 실행되지 않고, 독립적인 스레드에 배치된다. 이벤트 순환 스레드(event loop thread)가 요청을 수신하면 간단한 처리 후 바로 각각의 작업자 스레드에 분배하는 식이다. 다중 스레드를 이용한 병행 실행은 시스템의 다중 코어를 최대한 활용하여 요청 처리를 가속화한다. 물론 이 작업자 스레드를 스레드 풀(thread pool)로 구현하는 것도 가능하다. 이런 설계 방법에는 **반응자 패턴(reactor pattern)** 이라는 이름이 붙어 있다.

## 반응자 패턴
카페를 비유로 들면, 고객은 이벤트 순환에 해당하고, 주방 요리사는 작업자 스레드에 해당하며, 카페를 운영하는 전체적인 방식은 반응자 패턴에 해당한다. 반응자 패턴은 I/O 다중화와 이벤트 기반 처리를 통해 다중 네트워크 요청을 처리한다.

## 이벤트 순환과 입출력
요청 처리 과정에 입출력 작업도 포함된다고 가정해 보자.
1) 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우: 이때는 직접 논블로킹 인터페이스를 호출해도 스레드가 일시 중지되지 않으며, 인터페이스가 즉시 반환되므로, 이벤트 순환에서 직접 호출하는 것이 가능하다.
2) 입출력 작업에 블로킹 인터페이스만 있는 경우: 이때는 이벤트 순환 내에서 절대로 어떤 블로킹 인터페이스도 호출하면 안 된다는 것을 알아두어야 한다. 그렇지 않으면 이벤트 순환 스레드가 일시 중지될 수 있으며, 이벤트 순환이라는 엔진이 멈추는 것에 해당하기 때문에, 전체 시스템이 모두 앞으로 나아갈 수 없게 된다. 따라서 블로킹 입출력 호출이 포함된 작업은, 작업자 스레드에 전달해야 한다. 그래야만 이 작업으로 해당 작업자 스레드가 일시 중지되더라도, 다른 작업 스레드에 문제를 일으키지 않는다.

사실 전체적인 프레임웤크만 확정되어 있다면, 개발자는 작업자 스레드의 hanlder 함수에 대한 프로그래밍만 하면 된다. 

## 비동기와 콜백 함수
비즈니스가 발전하면 하나의 사용자 요청을 처리하는 데 여러 서버가 조합되어 사용될 수 있다. 예를 들어서, 사용자가 전자 상거래 앱에서 상품을 검색할 때, 하나의 검색 요청에 네 가지 백엔드(backend) 서비스가 관여할 수 있다. 먼저 검색 서버로 요청이 전성되면 간단한 처리를 진행한 후, 서버 A에 사용자 프로필과 같은 상세 정보를 요청한다. 다음으로 사용자의 검색어와 서버 A에서 얻은 사용자 프로필을 결합하여, 서버 B에 상품 검색을 요청한 후, 다시 서버 C에 재고 여부를 조회하여 일치하는 상품 정보를 가져온다. 마지막으로 검색 서비스는 최종 결과에서 재고가 없는 상품을 필터링한 최종 결과를 사용자에게 반환한다.

서버는 일반적으로 원격 프로시저 호출(remote procedure call), 즉 RPC를 통해 통신한다. RPC는 네트워크 설정, 데이터 전송, 데이터 분석 등 지루한 작업을 담아 프로그래머가 일반 함수를 호출하는 것처럼 네트워크로 통신할 수 있도록 한다.
```aiignore
GetUserInfo(request, response);
```
외부에서 보면 이것은 그냥 일반적인 함수이지만, 이 함수의 최하위 계층에서는 네트워크 통신을 수행할 수 있다. 대상 서버에 요청을 보내고, 그 응답을 받아 매개변수 response에 저장한다. 해당 함수가 반환되면, 바로 response로 결과를 확인할 수 있다.
이제 해당 서버에 대응하는 hanlder 함수는 다음과 같이 작성할 수 있다.
```aiignore
void handler(request) {
    A;
    B;
    GetUserInfo(request, response);  // 서버 A에 요청
    C;
    D;
    GetQueryInfo(request, response); // 서버 B에 요청
    E;
    F;
    GetStorkInfo(request, response); // 서버 C의 요청
    G;
    H;
}
```
Get으로 시작하는 것은 RPC 호출이다. 주의할 점은 이 RPC 호출들은 모두 블로킹 호출이기 때문에, 사용자가 응답하기 전에는 함수가 반환되지 않는다. handler 함수 구현 방법의 장점은 코드가 명확하고 이해하기 쉽지만, 반면에 유일한 문제는 블로킹 호출로 스레드가 일시 중지될 수 있고 블로킹 호출이 여러 번 발생하면, 스레드가 빈번하게 중단될 수 있다는 것이다. 이런 시스템은 CPU의 리소스를 최대한 활용하지 못할 가능성이 매우 높은데, 작업자 스레드가 많은 시간을 사용자 응답을 기다리는 데 소모하고 CPU가 실행할 수 있도록 준비 완료된 스레드가 많지 않은 상황이 될 수 있기 떄문이다. 만약 더 많은 작업자 스레드를 열면 스레드의 스케줄링과 전환에 드는 부담이 증가할 뿐만 아니라, CPU의 컴퓨팅 리소스가 불필요한 작업에 낭비된다. 따라서 더 나은 방식은 동기 방식의 RPC을 비동기 호출로 수정하는 것이다. 이제 RPC 호출 형식은 다음과 같이 바뀐다.
```aiignore
GetUserInfo(request, callback);
```
함수에 대한 비동기 호출은 호출 스레드를 블로킹하지 않기 때문에, 함수가 즉시 반환된다. 단, 함수가 반환될 때 사용자 응답에 대한 결과가 없을 수 있다. 이때는 반드시 GetUserInfo() 함수를 호출한 후, 처리할 내용을 콜백 함수에 담아 RPC 호출에 포함시켜야 한다.
이제 전체적인 흐름 처리는 다음과 같다.
```aiignore
void handler_after_GetStorkInfo(response) { 
    G;
    H;
}
void handler_after_GetQueryInfo(response) {
    E;
    F;
    GetStorkInfo(request, handler_after_GetStorkInfo); // 서버 C에 요청
}
void handler_after_GetUserInfo(response) {
    C;
    D;
    GetQueryInfo(request, handler_after_GetQueryInfo); // 서버 B에 요청
}
void handler(request) {
    A;
    B;
    GetUserInfo(request, handler_after_GetUserInfo); // 서버 A에 요청
}
```
이제 주 프로세스는 네 개로 분할되고, 콜백 안에 콜백이 포함되어 있다. 하지만 이것은 여전히 사용자 서비스가 세 개에 불과한 상황에 대응할 뿐이며, 사용자 서비스가 더 많아지면 이런 형태의 코드는 거의 관리가 불가능하다. 콜백 지옥에 빠지게 되는 것이다. 그렇다면 비동기 프로그래밍의 효율성과 동기 프로그래밍의 단순성을 결합한 기술은 없을까? 바로 코루틴이다.

## 코루틴: 동기 방식의 비동기 프로그래밍
handler 함수를 코루틴으로 작성하면 다음과 같다.
```aiignore
A;
B;
GetUserInfo();
C;
D;
GetQueryInfo();
E;
F;
GetStorkInfo();
G;
H;
```
handler 함수의 코드 구현은 여전히 동기로 작성되지만, yield로 CPU 제어권을 반환하는 등 RPC 통신이 시작된 후 적극적으로 바로 호출된다는 점은 다르다. (이때 RPC 호출 함수 또는 네트워크 데이터 전송 함수를 수정해야 yield로 CPU 제어권을 반환할 수 있다.) 여기서 가장 중요한 점은, 코루틴이 일시 중지되더라도 작업자 스레드가 블로킹되지 않는다는 것이다. 이것이 코루틴과 스레드를 사용하는 블로킹 호출의 가장 큰 차이점이다.

코루틴이 일시 중지되면, 작업자 스레드는 준비 완료된 다른 코루틴을 실행하기 위해 전환되며, 일시 중지된 코루틴에 할당된 사용자 서비스가 응답한 후, 그 처리 결과를 반환하면 다시 준비 상태가 되어 스케줄링 차례가 돌아오길 기다린다. 이후 코루틴은 마지막으로 중지되었던 곳에서 이어서 계속 실행된다. 이렇듯 코루틴의 도움으로 동기 방식으로 프로그래밍하더라도, 비동기 실행과 같은 효과를 얻는다는 목표를 달성할 수 있다.

이벤트 순환은 요청을 받은 후, 우리가 구현한 handler 함수를 코루틴에 담아 스케줄링과 실행을 위해 각 작업자 스레드에 배포한다. 작업자 스레드는 코루틴을 획득한 후, 진입 함수인 handler를 실행하기 시작한다. 어떤 코루틴이 RPC 요청으로 능동적으로 CPU의 제어권을 반환하면, 작업자 스레드는 준비 상태인 다른 코루틴을 실행한다. 이와 같이 비록 코루틴이 블로킹 방식으로 RPC를 호출하더라도, 작업자 스레드는 블로킹되지 않기 떄문에, 시스템 리소스를 효율적으로 사용하겠다는 목적을 달성할 수 있다. 

## CPU, 스레드, 코루틴
CPU, 스레드, 코루틴은 서로 다른 계층 구조에 위치한다. CPU는 하드웨어에, 스레드는 커널 상태에, 코루틴은 사용자 상태에 위치한다.

CPU는 기계 명령어를 실행하여 컴퓨터를 움직이게 한다. 스레드는 일반적으로 커널 상태 스레드라고도 하며, 커널로 생성되고 스케줄링을 한다. 이때 커널은 스레드 우선순위에 따라 CPU 연산 리소스를 할당한다. 반면에 코루틴은 커널 입장에서는 알 수 없는 요소로, 코루틴이 얼마나 많이 생성되었든 커널은 이와 관계없이 스레드에 따라 CPU 시간을 할당한다. 프로그래머는 스레드에 할당된 시간 내 실행할 코투린을 결정할 수 있는데, 스레드에 할당된 CPU 시간을 사용자 상태에서 재차 할당하는 것에 해당한다. 이 할당은 사용자 상태에서 발생하므로, 코루틴을 사용자 상태 스레드라고도 한다. 즉, 코루틴은 본빌적으로 사용자 상태에서 스레드의 CPU 시간을 2차 할당하는 것이다.

---
1. 사용자 상태(User Mode)와 커널 상태(Kernel Mode)
- 사용자 상태는 응용 프로그램이 실행되는 환경으로, 프로그램은 하드웨어 자원(CPU, 메모리 등)에 직접적으로 접근할 수 없습니다. 하드웨어 자원에 접근하려면 커널을 통해서 간접적으로 접근해야 합니다.
- 커널 상태는 운영체제가 실행되는 특권 모드로, 하드웨어 자원을 직접 관리하고 CPU 제어권을 가지고 있습니다. 커널은 스레드, 메모리, 파일 시스템 등을 제어 및 관리합니다.
---

2. CPU, 스레드, 코루틴의 관계
- CPU는 하드웨어에서 명령을 실행하는 기본적인 연산 장치입니다.
- 스레드는 커널에 의해 스케줄링되고, CPU 시간을 할당받아 실행됩니다. 각 스레드는 CPU 리소스를 통해 실제 연산 작업을 수행합니다.
- 코루틴은 스레드 내부에서 실행되는 가벼운 비동기 작업 단위입니다. 코루틴은 CPU 자원을 직접 배정받는 것이 아니라, 스레드가 할당받은 CPU 시간 내에서 실행됩니다.

3. 코루틴과 CPU 제어권
- 코루틴은 커널이 알지 못하는 단위로, 커널은 오로지 스레드 단위로만 CPU 시간을 할당합니다. 코루틴이 CPU 제어권과 직접적인 관계가 없다는 의미는, 코루틴이 커널에 의해 직접 스케줄링되거나 CPU 자원을 배정받지 않는다는 뜻입니다. 대신, 스레드가 배정받은 CPU 시간을 코루틴이 활용하는 방식입니다.

CPU, 스레드, 코루틴

- 코루틴의 스케줄링은 코루틴 라이브러리나 런타임 환경에서 관리됩니다. 예를 들어, Kotlin에서는 Dispatchers라는 스케줄러가 코루틴을 스케줄링합니다. 코루틴 스케줄러는 코루틴이 어느 스레드에서 실행되고 중단될지를 관리하는 역할을 합니다.
- Dispatchers.Main: 주로 UI 스레드에서 코루틴을 실행.
- Dispatchers.IO: 입출력 작업을 위한 스레드 풀에서 실행.
- Dispatchers.Default: CPU 집약적인 작업을 위한 스레드 풀에서 실행.
- Dispatchers.Unconfined: 특정 스레드에 종속되지 않음.

5. 결론적으로
- 커널은 스레드를 관리하고, 스레드에 CPU 시간을 할당합니다.
- 코루틴은 스레드 내에서 실행되며, 사용자 상태에서 관리됩니다. 커널은 코루틴의 존재를 알지 못하고, 오직 스레드 단위로만 작업을 처리합니다.
- 코루틴 스케줄러는 프로그래머가 정의한 규칙에 따라 코루틴의 실행 순서와 스레드 배정을 관리합니다.
- 코루틴은 스레드보다 더 가벼운 비동기 작업 단위로, CPU 자원을 효율적으로 사용할 수 있게 도와줍니다.

- 코루틴은 CPU 자원을 직접적으로 제어하지 않지만, 스레드가 할당받은 CPU 자원을 사용해 비동기적으로 작업을 처리합니다.
---
