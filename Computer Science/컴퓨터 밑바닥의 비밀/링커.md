# 링커
- 소스 코드를 담고 있는 파일을 컴파일하면 기계 명렁어에 해당하는 코드를 저장하는 파일이 생성되는데, 이 파일을 대상 파일(.o, object file)이라고 한다. 
- 링커는 컴파일러가 생성한 파일 여러 개를 묶어 하나의 실행 파일을 생성한다.

## 링커는 이렇게 일한다
- 심벌 해석(symbol resolution): 링커는 모듈 사이의 종속성(dependency)가 올바르게 설정되어 있는지, 즉, 인터페이스 구현이 종속된 모듈에서 사용 가능한지 확인한다. 우리가 참조하고 있는 외부 심벌(external symbol)에 대한 실제 구현이 어느 모듈이든지 단 하나만 있어야 하고, 링커는 이를 찾아내 연결하는 작업을 하는 것이다.
- 실행 파일 생성: 링커는 대상 파일을 모두 모아 하나의 실행 파일로 만든다.
- 재배치(relocation): 한 소스 파일에서 다른 모듈에 정의되어 있는 함수를 참조할 때, 컴파일러가 소스 파일을 컴파일하는 시점에는 함수가 어느 메모리 주소(memory address)에 위치할지 정확하게 알 수 없기 때문에 일단은 N으로 표시해두고 넘어가면, 링커가 이런 표시들을 확인하고 한데 모아 실행 파일을 생성하는 과정에서 함수의 정확한 주소를 확인하고 실제 메모리 주소로 대체해 준다.

## 심벌 해석: 수요와 공급
- 심벌(symbol): 전역 변수(global variable)과 함수(function)의 이름을 포함하는 모든 변수의 이름. 단, 지역 변수(local variable)은 모듈 내에서만 사용되어 외부 모듈에서 참조할 수 없기 때문에, 링커의 관심 대상이 아니다.
- 링커는 대상 파일에서 참조하고 있는 각각의 모든 외부 심벌마다 대상 정의가 반드시 존재하는지, 또, 단 하나만 존재하는지 확인해야 한다.
- 컴파일러는 인간이 이해할 수 있는 코드를 기계 명령어로 생성할 때 이 명령어를 실행시키는 데이터도 생성해서 대상 파일에 포함시킨다. 즉, 대상 파일은 두 가지 부분으로 나뉜다:
  1) 코드 영역(code section): 명령어 부분. 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분.
  2) 데이터 영역(data section): 소스 파일의 전역 변수가 저장되는 부분. (로컬 변수는 프로그램이 실행된 후 스택 영역에서 생성되고 사용하면 제거되기 때문에, 대상 파일에는 별도로 저장되지 않는다)
  3) 심벌 테이블(symbol table): 소스 파일마다 외부에서 참조 가능한 심벌이 어떤 것인지(해당 소스 파일이 정의한 심벌), 또한 반대로 어떤 외부 심벌을 침조하고 있는지(해당 소스 파일이 사용하는 외부 심벌)에 대한 정보를 표에 기록한다. 
- 링커는 각 대상 파일에서 사용할 외부 심벌이 심벌 테이블에서 유일한 정의(unique definition)를 발견 가능한지 확인하는 작업을 담당하는데, 이게 바로 심벌 해석이다. 참조된 변수나 함수 정의를 찾는 것이다. 
- 만약 심벌에 대한 참조가 없으면, 즉, 어떤 함수가 참조되었지만 정의되지 않았다면, 링커는 오류를 발생시킨다.

## 정적 라이브러리, 동적 라이브러리, 실행 파일
- 라이브러리: 특정 기능을 구현한 코드의 집합체로, 다른 프로그램에서 재사용할 수 있도록 만든 것. 라이브러리는 크게 정적 라이브러리와 동적 라이브러리로 나눌 수 있으며, 각각의 특징과 장단점이 있다.
  
#### 정적 라이브러리
- 정적 라이브러리 (Static Library): 컴파일 타임에 프로그램에 포함되어 실행 파일의 일부분이 되는 라이브러리. 주로 .lib (Windows) 또는 .a (Unix 계열) 확장자를 가진다. 정적 라이브러리를 사용하면, 컴파일러는 라이브러리를 실행 파일에 복사하여 포함시킨다. 실행 파일을 생성할 때 미리 컴파일이 완료된 정적 라이브러리는 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제된다.
- 정적 링크 (static link): 컴파일 타임에 정적 라이브러리와 오브젝트 파일(대상 파일)의 코드를 실행 파일에 포함시키는 과정이다. 이 과정에서는 링커가 각 정적 라이브러리와 오브젝트 파일에서 필요한 코드를 추출하여 하나의 실행 파일로 합친다. 코드가 의존하는 외부 코드를 매번 컴파일하지 않아도 되기 때문에 컴파일 속도가 빨라진다.
- 정적 링크는 정적 라이브러리와 대상 파일(오브젝트 파일)을 한데 모아 각각의 파일에서 데이터 영역과 코드 영역을 결합한다. 실행 파일에도 코드 영역과 데이터 영역이 있으며, 또한 특수한 심벌인 _start가 존재한다. CPU는 이 심벌 주소에서 프로그램을 실행하는 데 필요한 기계 명령어를 찾고 실행한 후에야 비로소 main 함수를 실행하기 시작한다.
- 정적 라이브러리의 장점: 
  1. 독립성: 실행 파일이 외부 의존성 없이 독립적으로 동작할 수 있다.
	1. 성능: 실행 시 동적 라이브러리를 로드할 필요가 없어 약간의 성능 이점을 가질 수 있다.
	2. 안정성: 라이브러리가 프로그램에 포함되므로, 라이브러리 버전이 변경되거나 삭제되더라도 프로그램의 동작에 영향을 미치지 않는다.
- 정적 라이브러리의 단점:
	1. 중복 데이터: 모든 프로그램에 적용되는 표준 라이브러리를 사용한다면, 정적 링크로 생성된 실행 파일은 모두 동일한 코드와 데이터의 복사본을 갖게 된다. 즉, 정적 라이브러리를 사용하는 실행 파일은 모두 중복된 데이터를 가진다.
	2. 재컴파일 필요: 정적 라이브러리의 코드가 변경될 때마다 해당 라이브러리에 종속된 프로그램을 다시 컴파일해야 한다.
	3. 파일 크기 증가: 모든 정적 라이브러리가 실행 파일에 포함되므로, 실행 파일의 크기가 커질 수 있다.

#### 동적 라이브러리
- 동적 라이브러리 (Dynamic Library): 공유 라이브러리(shared Library) 또는 동적 링크 라이브러리(dynamic link library)라고도 한다. 
- 윈도에서 흔히 보는 DDL 파일이 동적 라이브러리이고(.dll), 리눅스의 동적 라이브러리는 .so 확장자와 lib 접두사를 사용한다. ex) libMath.so
- 동적 라이브러리를 사용하면 참조된 라이브러리의 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함된다. 이 필수 정보는 실행 파일 내에 저장되며, 동적 링크(dynamic linking)가 일어날 때 사용된다. 따라서 실행 파일의 크기를 줄일 수 있다.
- 정적 라이브러리는 컴파일 단계에서 실행 파일에 함께 복사되기 때문에 실행 파일에 정적 라이브러리 전체 내용이 포함되는 반면, 동적 라이브러리에 의존하는 실행 파일에는 컴파일 단계에서 필수 정보만 저장되기 때문에 동적 링크는 실제 프로그램의 실행 시점까지 미루는 것이다. 동적 링크에는 두 가지 방식이 있다:
   1) 프로그램이 메모리에 적재(loading)될 때 동적 링크 진행: 적재는 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동하시키는 과정으로, 이 과정에서 적재 도구(loader)라는 전용 프로세스가 실행된다. 실행 파일을 적재하고 나면 적재 도구는 실행 파일이 동적 라이브러리에 의존하는지 여부를 확인할 수 있고, 만약 동적 라이브러리가 필요하다면 동적 링커 (dynamic linker)라는 별도의 프로세스가 실행되어 참조하는 동적 라이브러리 존재 여부와 위치, 심벌의 메모리 위치 등을 확인하여 링크 과정을 마무리한다. 만약 동적 링크 과정에 문제가 발생한다면, 종속된 동적 라이브러리를 발견하지 못했다는 오류 메세지를 표시하고 실행이 종료된다. 따라서 적재 중 동적 링크를 사용하려면, 실행 파일이 어떤 동적 라이브러리를 참조하는지 컴파일러에 명시적으로 알려주어야 한다. 
   2) 실행 시간 동적 링크(runtime dynamic linking): 링크 과정을 프로그램이 실행된 이후로 미룬다. 실행 파일이 실행될 때까지 어떤 동적 라이브러리에 의존하는지 알 필요가 없다. 이 방식에서는 실행 파일을 생성하는 과정에서 실행 파일 내부에 동적 라이브러리 정보가 저장되지 않고, 프로그래머가 코드에 특정 API를 사용해ㅑ서 필요할 때마다 동적 라이브러리를 직접 동적으로 적재할 수 있다. 

- 장점:
    - 파일 크기 감소: 실행 파일에 라이브러리를 포함하지 않으므로, 실행 파일의 크기가 작아진다.
  - 업데이트 용이성: 라이브러리를 독립적으로 업데이트할 수 있어, 프로그램을 재컴파일하지 않고도 라이브러리의 버그 수정이나 기능 추가가 가능하다.
  - 메모리 절약: 여러 프로그램이 동일한 동적 라이브러리를 공유하여 메모리 사용량을 줄일 수 있다.

- 단점:
  - 의존성 문제: 실행 파일이 필요한 라이브러리를 찾지 못하면 프로그램이 실행되지 않을 수 있다.
  - 복잡성 증가: 다양한 버전의 라이브러리 관리가 복잡해질 수 있다.
  - 성능 저하: 라이브러리를 로드하는 데 시간이 걸릴 수 있으며, 이로 인해 약간의 성능 저하가 발생할 수 있다.

정적 라이브러리는 독립적으로 실행할 수 있고 성능상의 이점을 제공하지만, 파일 크기 증가와 재컴파일 필요성 등의 단점이 있다. 반면, 동적 라이브러리는 파일 크기를 줄이고 업데이트를 용이하게 하지만, 의존성 문제와 성능 저하의 단점이 있다.

##### Q. 안드로이드에서 사용하는 라이브러리들은 정적 라이브러리일까 동적 라이브러리일까?
안드로이드에서 대부분의 라이브러리, 예를 들어 Jetpack Compose 같은 것들은 정적 라이브러리로 사용된다. 이는 다양한 기기와 운영 체제에서의 호환성과 안정성을 보장하기 위해서이다. 정적 라이브러리는 APK 파일에 모든 필요한 코드와 리소스를 포함시켜 배포를 단순화하고, 실행 시 성능 최적화를 가능하게 한다. 또한, 일관된 업데이트와 효율적인 메모리 관리를 위해 정적 라이브러리가 선호된다. 이로 인해 파일 크기가 증가할 수 있지만, 그 단점보다 장점이 더 중요하게 여겨진다. (안드로이드 앱은 다양한 기기와 운영 체제 버전에서 실행되어야 한다. 정적 라이브러리를 사용하면 필요한 모든 코드와 리소스를 APK에 포함시킬 수 있으므로, 라이브러리의 특정 버전이 설치되지 않은 기기에서도 안정적으로 동작할 수 있다. 이는 앱의 호환성과 안정성을 보장하는 데 중요한 역할을 한다. 또한 정적 라이브러리를 사용하면 개발자가 APK에 필요한 모든 종속성을 포함시켜 배포할 수 있으므로, 사용자는 추가적으로 라이브러리를 설치할 필요가 없다. 동적 라이브러리의 경우, 사용자가 필요한 라이브러리를 별도로 설치하거나 적절한 버전이 설치되어 있는지 확인해야 하는 번거로움이 있을 수 있다.)

#### 동적 라이브러리의 장단점
##### 장점
- 리소스 절약: 동적 라이브러리를 사용하면 의존하는 프로그램 개수가 얼마가 되었든 상관없이 디스크에는 동적 라이브러리의 복사본 하나만 저장된다. 또한 메모리에 적재되는 동적 라이브러리의 코드 역시 모든 프로세스가 하나의 코드를 공유하기 때문에 하나면 충분하다. 따라서 동적 라이브러리는 공유 라이브러리라고도 한다.
- 업그레이드와 버그 수정이 쉽다: 동적 라이브러리의 코드가 수정되면 해당 동적 라이브러리만 다시 컴파일하면 된다. 실행 파일에는 동적 라이브러리에 대한 필수 정보만 저장되어 있어서, 실행 파일을 매번 다시 컴파일 할 필요 없이 동적 라이브러리만 새 버전으로 교체하면 다음에 실행 파일이 실행될 때 새 버전의 동적 라이브러리가 사용된다. 
- 프로그램 기능을 쉽게 확장할 수 있다: 동적 링크는 프로그램 실행 시간에 일어나는 것도 가능하기 때문에, 프로그램 기능을 쉽게 확장할 수 있다. 예를 들어 플러그인(plug-in)의 경우 사전에 함수 여러 개를 미리 정의해 두고, 플러그인에서는 이 함수들을 구현한다. 그리고 동적 라이브러리의 방식에 따라 플러그인을 적재하여 프로그램이 사용할 수 있도록 한다. 이렇게 새로운 동적 라이브러리를 제공하기만 하면 프로그램은 새로운 기능을 가지게 되며, 이것이 플러그인을 구현하는 방법 중 하나이다. 
- 여러 언어를 혼합하여 개발할 수 있다: 예를 들어서 더 높은 성능이 요구되는 코드의 핵심 부분은 동적 라이브러리를 통해 C/C++으로 작성된 함수를 직접 호출할 수 있다. 코드의 재사용 효율도 훨씬 높일 수 있는 것이다.

##### 단점
- 성능 저하: 동적 라이브러리는 프로그램이 적재되는 시간 또는 실행 시간에 링크가되기 때문에 동적 링크를 사용하는 프로그램은 정적 링크를 사용할 때마다 성능이 약간 떨어진다.
- 위치 독립 코드: 동적 라이브러리의 코드는 특정 메모리 주소와 독립적으로 동작하기 때문에 위치 독립 코드(position-independent code)로 불린다. 동적 라이브러리는 메모리에 단 하나의 복사본만 존재하고 해당 코드는 여러 프로세스가 공유할 수 있기 때문에, 동적 라이브러리의 코드는 임의의 메모리 절대 주소(absolute address)를 참조할 수 없다. 이런 주소 독립적 설계는 동적 라이브러리의 변수를 참조할 때 더 간접적인 접근을 해야 한다는 것을 의미한다.
- 유연하지 않은 설치와 배포: 적재할 때 동적 링크를 수행하는 프로그램은 실행 파일로만은 실행이 불가능하다. 종속된 동적 라이브러리를 제공하지 않거나, 그 버전이 호환되지 않을 경우 프로그램이 실행되지 않는다. 이런 문제로 프로그램의 설치와 배포에 어려움을 겪을 수 있다. 

## 재배치: 섬벌의 실행 시 주소 결정하기
- 컴파일러는 컴파일을 통해 대상 파일을 생성할 때 함수나 변수가 어느 메모리 주소에 적재될지 알 수 없고, 일단 0x00로 지정하여 호출한다는 사실만 기록해둔다. 그리고 이후에 링커가 재배치를 실행할 수 있도록 단서를 남겨두는데, 메모리 주소를 확정할 수 없는 변수를 발견할 때마다 .relo.text에는 해당 명령어를 저장하고, .relo.data에는 해당 명령어와 관련된 데이터를 저장한다 (대상 파일은 코드 영역, 데이터 영역, 심벌 테이블, .relo.text와 .relo.data가 있다). 예를 들어서 함수의 위치를 오프셋으로 대략적으로 적어두는데, .relo.text에 다음과 같이 적을 수 있다: 코드 영역의 시작 주소 기준 오프셋이 60 바이트인 위치에서 함수 심벌을 발견했지만 실행 시에 어떤 주소에서 실행해야 할지 알 수 없다'. 
- 뒤이어 링커가 대상 파일에서 동일한 유형의 영역끼리 병합하면 심벌 해석(symbol resolution)을 하는데, 모든 기계 명령어와 전역 변수가 프로그램 실행 시간에 위치할 메모리 주소를 이때 결정할 수 있다. 앞선 예제에서 링커가 각 대상 파일의 .relo.text 영역을 하나씩 읽어 기계 명령어를 수정행햐 나는 심벌이 있으며, 이 심벌의 코드 영역 시작 주소 기준 오프셋이 60바이트라는 것을 확인하고 이 정보를 이용해서 실행 파일에서 해당 call 명령어를 정확하게 찾고, 이동할 소스 주소를 수정해준다. 이렇게 심벌의 메모리 주소를 수정하는 과정을 재배치(relocation)이라고 한다. 그럼 링커는 어떻게 실행 시간 메모리 주소를 미리 알 수 있을까?

# 가상 메모리 
프로그램이 실행되면 해당 프로그램의 프로세스(process)가 메모리에 적재되는데, 프로세스는 동일한 형태로 메모리에 적재된다. 메모리의 상위 주소(higher address)에 스택 영역이 존재하고,아래에 비어 있는 큰 공간이 존재하고, 이어서 힙 영역이 존재한다. 그리고 마지막으로 데이터 영역과 코드 영역(code segment)이 위치하는데, 이 두 영역은 실행 파일의 내용이 메모리에 적재되는 곳이다. 모든 프로세스가 동일한 형태로 메모리가 적재되기 때문에 모든 프로그램은 실행된 후 코드 영역이 예외 없이 메모리 주소 0x400000에서 시작한다. 
예를 들어서 두 프로그램 A와 B가 동시에 실행 중이라고 가정할 때, CPU가 프로그램 A를 실행할 때 메모리 주소 0x400000에서 가져온 명령어는 프로그램 A에 속하고, 프로그램 B를 실행할 때 메모리 주소 0x400000에서 가져온 명령어는 프로그램 B에 속한다. 즉, 둘 다 메모리 주소 0x400000에서 가져온 것이지만 그 데이터는 서로 동일하지 않다. 

이런 일을 가능하게 하는 것은 바로 운영 체제의 가상 메모리 기술 덕분이다. 

가상 메모리는 말 그대로 물리적으로 존재하지 않는 가짜 메모리다. 가상 메모리는 각각의 프로그램이 실행 중일 때, 자기 자신이 모든 메모리를 모두 독점적으로 사용하고 있는 것처럼 착각하게 만든다. 예를 들어서 32비트 시스템에서는 실제로 시스템에 설치된 물리적 메모리가 얼마가 되었든 자신이 232바이트, 즉 4GB 메모리를 독점하고 있다고 생각한다. 
따라서 프로세스가 적재되는 형태는 실제 물리 메모리의 형상이 아닌 논리로만 존재하는 허상일 뿐이다. 이는 마치 우리가 파일을 연속적으로 읽고 있다고 생각하지만, 실제로는 그 데이터가 디스크 전체에 무작위로 흩어져 있는 것과 마찬가지이다. 이것이 바로 모든 프로그램이 동일한 표준적인 메모리 구조를 가질 수 있는 이유이다. 

링커가 실행 파일을 생성하자마자 실행 시 심벌의 메모리 주소를 결정할 수 있는 것도 프로그램 실행 여부와 관계없이 프로세스 메모리 구조를 알고 있기 때문이다. 64비트 시스템을 예로 들면 코드 영역은 언제나 메모리 주소 0x400000에서 시작하고, 스택 영역은 항상 메모리의 상위 주소에 위치한다. 이런 메모리 구조를 사용하면 메모리 주소가 가상이라고 하더라도 실행 시 심벌의 메모리 주소를 확인할 수 있다. 하지만 사실상 링커는 프로그램이 실행될 때 명령어나 데이터가 실제로 존재하는 물리 메모리(physical memory)의 어디에 위치하는지 전혀 신경 쓰지 않는다. 표준적인 가상 메모리 공간에 대해 실행 시 메모리 주소를 생성하면 링커 설계가 매우 크게 간소화된다. 
하지만 결국에는 데이터와 명령어가 물리 메모리에 저장되어야 한다. 그렇다면 CPU가 프로그램 A를 실행하여 메모리 주소 0x400000에 접근할 때, 실제로 명령어를 꺼내는 물리 메모리 주소는 어떻게 찾아야 할까? 실행 파일을 실행하려면 물리 메모리에 적재되어야 한다는 것은 이미 알고 있다. 실행 파일의 코드 영역이 물리 메모리 주소 0x80ef0000에 적재된다고 가정하면, 시스템에는 다음과 같은 사상(mapping) 관계가 추가된다. 단, 실제 운영 체제의 모든 메모리 주소에 대해 이런 사상 관계를 유지하는 것은 아니며 메모리 페이지(memory page) 단위로 관리된다. 이런 사상 관계를 기록한 표를 페이지 테이블(page table)이라고 한다. 각각의 프로세스에는 자신만의 페이지 테이블이 있으며, CPU가 프로그램 A를 실행하고 메모리 주소 0x400000에 접근하면 특별히 설계된 하드웨어가 페이지 테이블을 참조하여 물리 메모리 주소 0x80ef0000으로 변환한 후 접근한다. 

가상 메모리의 기본 원리
1. 모든 프로세스의 가상 메모리는 표준화되어 있고 크기가 동일하다. 프로세스마다 각 영역의 크기가 다를 수는 있지만 영역이 배치되는 순서는 동일하다.

2. 실제 물리 메모리의 크기는 가상 메모리의 크기와는 무관하며 물리 메모리에는 힙 영역, 스택 영역 등 영역 구분조차 존재하지 않는다. 단, 운영 체제마다 이는 조금씩 다를 수 있다.

3. 모든 프로세스는 자신만의 페이지 테이블을 가지고 있으며, 같은 가상 메모리 주소라도 페이지 테이블을 확인하여 서로 다른 물리 메모리 주소를 획득한다. 이런 이유로 CPU는 동일한 가상 메모리 주소에서 서로 다른 내용을 가져올 수 있다.

