# 스레드간 공유되는 프로세스 리소스

## 스레드 전용 리소스(thread-private resources)
- 상태 변화 관점에서 보면 스레드는 사실 함수 실행이다. CPU는 하나의 진입 함수의 명령어를 실행해서 실행 흐름인 스레드를 형성하기 때문이다.
- 그렇다면 바로 함수 실행에 필요한 정보가 스레드 전용 리소스라는 뜻이다.
- 함수의 실행 시간 정보는 스택 영역을 구성하는 스택 프레임에 저장된다. 이때 스택 프레임에는 함수의 반환값, 다른 함수를 호출할 때 전달되는 매개변수, 함수 내에서 사용되는 지역 변수와 레지스터 정보가 저장된다.
- 각 스레드는 자신만 사용할 수 있는 스택 영역을 가지므로, 스레드가 여러 개 있을 때는 여러 스택 영역이 존재하게 되는 것이다.
- 스택 영역 외에는 다음에 실행될 명령어 주소를 저장하는 PC 레지스터(register), 스레드 스택 영역에서 스택 상단(setack top) 위치를 저장하는 스택 포인터(stack pointer) 등 CPU가 기계 명령어를 실행할 때 내부 레지스터 값도 스레드의 현재 실행 상태에 속한다. 이런 레지스터 정보도 역시 스레드 전용으로, 다른 스레드에서는 이런 레지스터 정보에 접근할 수 없다.
- 스레드 상황 정보(thread context): 스레드에 속한 스택 영역, 프로그램 카운터, 스택 포인터, 함수 실행 시 사용되는 레지스터 정보를 통틀어 스레드 상황 정보(thread context)라고 한다.
- 전용 리소스를 제외한 나머지는 모두 스레드 간에 공유되는 리소스에 해당한다. 즉, 스레드는 프로세스 주소 공간에서 스택 영역을 제외한 나머지 영역(힙, 데이터, 코드)를 모두 공유한다. 

## 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다
- 프로세스 주소 공간의 코드 영역에는 컴파일 후 생성된 실행 가능한 기계 명령어가 저장된다. 이런 기계 명령어는 실행 파일에 저장되어 있으며, 프로그램이 시작될 때 프로세스 주소 공간에 적재된다.
- 코드 영역을 스레드간에 공유되므로 어떤 함수든지 모두 스레드에 적재하여 실행할 수 있고, 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능하다. 따라서 코드 영역은 모든 스레드가 공유하는 영역이다.
- 코드 영역은 읽기 전용(read-only)이기 때문에, 프로그램이 실행되는 동안에는 어떤 스레드도 코드 영역 내용을 변경할 수는 없다. 따라서 프로세스 내 모든 스레드가 코드 영역을 공유하고 있지만, 코드 영역에 관해서는 스레드 안전 문제(thread safety issue)가 발생하지 않는다. 

## 데이터 영역: 모든 스레드가 데이터 영역의 변수에 접근할 수 있다
- 데이터 영역은 전역 변수가 저장되는 곳이다.
- 프로그램이 실행되는 동안 데이터 영역 내에 전역 변수의 인스턴스(instance)는 하나만 있기 때문에, 모든 스레드는 이 전역 변수에 접근할 수 있다.
- 다시 말해, 어떤 스레드가 이 전역 변수 값을 변경하면, 이후 다른 스레드에서 이 전역 변수 값을 확인해도 변경된 상태라는 의미이다.

## 힙 영역: 포인터가 핵심이다
- 힙 영역은 C/C++ 언어에서 malloc 함수와 new 예약어로 요청하는 메모리가 이 영역에 할당된다.
- 모든 스레드는 해당 변수 주소만 알 수 있다면, 다시 말해 포인터(pointer)만 얻을 수 있다면, 포인터가 가리키는 데이터에 접근할 수 있다. (모든 스레드는 포인터 s를 획득하면 해당 포인터가 가리키는 데이터에 접근할 수 있다)

---

**힙 영역 (Heap Segment)**

- 저장 내용: 동적으로 할당된 객체나 배열이 저장된다.
- JVM의 가비지 컬렉터가 메모리를 자동으로 관리해준다. 즉, 더 이상 사용되지 않는 객체는 가비지 컬렉션을 통해 정리된다.
- 여러 스레드가 동일한 힙 메모리의 객체를 참조할 수 있다. 그러나 이 경우 동시 접근에 대한 동기화 처리가 필요할 수 있다.

코드 영역: 함수와 명령어 코드가 저장되는 영역, 읽기 전용이며 모든 스레드가 접근 가능.  
데이터 영역: 전역 변수와 정적 변수가 저장되는 영역, 모든 스레드가 공유.  
힙 영역: 동적으로 생성된 객체가 저장되는 영역, 포인터를 통해 모든 스레드가 접근 가능.  
스택 영역: 함수 호출 시 생성되는 지역 변수들이 저장되는 영역, 각 스레드마다 독립적.

---

## 스택 영역: 공유 공간 내 전용 데이터
- 스택 영역은 스레드 전용 데이터이지만, 스택 영역에는 별도의 보호를 위한 작동 방식이 존재하지 않기 때문에, 다른 스레드에서 특정 스레드의 스택 영역을 볼 수 있다.
- 하나의 스레드가 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸 수 있다. 다시 말해, 스레드 여러 개가 하나의 프로세스에 속하는 경우, 하나의 스레드가 다른 스레드의 스택 영역이라고 하더라도 모두 데이터를 읽고 쓸 수 있다. 
- 이런 스레드 간의 미격리는 원인을 찾아내기 힘든 버그(bug)를 야기할 수 있다. 


## 동적 링크 라이브러리와 파일
- 링크는 컴파일 후에 최종적으로 실행 파일을 생성하는 핵심적인 단계이다.
- 정적 링크는 종속된 모든 라이브러리가 실행 파일에 포함된다. 모든 코드와 데이터가 포함되어 있기 때문에, 프로그램을 시작할 때 추가적인 작업이 필요하지 않는다.
- 동적 링크에는 실행 파일에 종속된 라이브러리의 코드와 데이터가 포함되어 있지 않기 때문에, 프로그램을 시작할 때 또는 실행 중일 때 종속된 라이브러리의 코드와 데이터를 찾아서 프로세스 주소 공간에 넣는 링크 과정이 완료되어야 한다.
- 동적 라이브러리의 코드와 데이터는 스택 영역과 힙 영역 중간에 있는 여유 공간에 배치되고, 이 영역은 모든 스레드가 공유하고 있다. 다시 말해, 프로세스 내 모든 스레드가 동적 라이브러리 코드의 데이터를 사용할 수 있다는 의미이다.
- 프로그램이 동작 중에 특정 파일을 열면 프로세스 주소 공간에 열린 파일 정보도 저장된다. 프로세스가 연 파일 정보는 모든 스레드에서 사용할 수 있으며, 이것 역시 스레드 간 공유 리소스에 속한다. 

## 스레드 전용 저장소 
- 스레드 전용 저장소(thread local storage): 이곳에 저장되는 변수는 모든 스레드에서 접근할 수 있지만, 변수의 인스턴스는 각각의 스레드에 속하기 때문에, 하나의 스레드에서 변수 값을 변경해도 다른 스레드에는 반영되지 않는다.
- 전역 변수 a 앞에 __thread라는 수식어를 붙이면 컴파일러가 전역 변수 a를 스레드 전용 저장소에 넣도록 지시하는 것이다. 따라서 스레드 t1에서 실행된 전역 변수 a에 대한 수정은, 스레드 t2에는 영향을 미치지 않는다. 
- 이렇게 스레드 전용 저장소를 사용하면 각각의 스레드에서 독점적으로 변수를 사용할 수 있다. 즉, 이 변수들은 모든 스레드에서 접근할 수 있지만, 해당 변수는 초기화한 후 각각의 스레드가 복사본을 가지게 되며, 하나의 스레드에서 변수 값을 변경하더라도, 다른 스레드에는 영향을 미치지 않는다. 

## 함수 반환값
- 함수가 값을 반환하는 경우(return by value)와 함수가 포인터를 반환하는 경우(return by reference) 두 가지 경우가 있다.
- 값을 반환하는 경우는 스레드 안전하며, 어떤 스레드가 함수를 호출하든 똑같은 값을 반환한다. 반면 정적 지역 변수(static local variable)을 사용하는 함수의 경우 변수의 주소의 반환하기 때문에, 잠재적으로 스레드 공유 리소스가 되며, 해당 주소를 획득할 수 있는(포인터) 모든 스레드가 해당 변수를 수정할 수 있다. 단, 싱글톤 패턴(singleton pattern)을 구현할 수 있는 방법(instance 그 자체를 반환하는)은 있다. 

## 스레드 안전이 아닌 코드 호출하기
- 함수 A가 스레드 안전이 아닌 함수를 호출할 때 함수 A는 스레드 안전할까?
- 함수 B가 전역 변수를 사용하고 그 값을 수정한다면, 해당 함수는 스레드 안전이 아니다. 하지만 이 함수를 함수 A가 호출하기 전에 잠금으로 보호하면, 함수 B는 스레드 안전하다. 잠금으로 전역 변수를 간접적으로 보호하기 때문이다. 
- 매개변수로 전달된 포인터가 전역 변수를 가리키는지 아닌지 알 수 없을 때는 스레드 안전성을 알 수 없지만, 이 함수를 호출할 때 전달하는 변수가 스레드 전용 리소스인 지역 변수면 스레드 안전하다.
 
## 스레드 안전 코드 구현하기
- 스레드 안전 구현은 스레드 전용 리소스와 공유 리소스를 중심으로 진행된다. 스레드 안전을 달성하려면, 먼저 어떤 것이 스레드 전용 리소스이고 어떤 것이 스레드 공유 리소스인지를 파악하고, 그에 따라 조치를 취해야 한다.
- 스레드 전용 저장소(thread local storage): 전역 리소스를 사용해야 하는 경우 스레드 전용 저장소로 선언할 수 있는지 확인해 본다. 모든 스레드에서 사용할 수 있지만 각 스레드마다 자체 복사본이 있으며, 이를 변경하더라도 다른 스레드에는 영향을 미치지 않기 때문이다.
- 읽기 전용(read-only): 전역 리소스를 반드시 사용해야 한다면, 해당 전역 리소스를 읽기 전용으로 사용해도 되는지 확인해 본다. 
- 원자성 연산(atomic operation): 원자성 연산은 도중에 중단되지 않기 떄문에, 이런 변수에 대한 연산에는 전통적인 방식의 잠금으로 보호가 필요하지 않는다.
- 동기화 시 상호 배제(mutual exclusion in synchronization): 한 번에 하나의 스레드만 공유 리소스에 접근할 수 있도록 스레드가 접근하는 공유 리소스 순서를 프로그래머가 유지시켜 준다. 뮤텍스(mutex), 스핀 잠금(spin lcok), 세마포어(semaphore) 등 여러 가지 동기화 시 상호 배제를 위한 작동 방식 모두가 이 목적을 위해 사용될 수 있다.
- 커널 스레드(kernel thread): 스레드의 생성, 스케줄링, 종료를 모두 운영 체제가 수행한다. 프로그래머는 스레드가 어떻게 생성되고 스케줄링 되는지 전혀 관여할 수 없다. 운영 체제에 의존하지 않은 상황에서 직접 스레드를 구현하려면, 스레드보다 더 가벼운 실행 흐름인 코루틴으로 구현할 수 있다.

---

1. 스레드 전용 저장소 (Thread Local Storage)

	•	안드로이드에서 ThreadLocal 클래스를 사용하면 각 스레드마다 개별적인 데이터를 저장할 수 있습니다. 이 방법을 사용하면 특정 스레드가 가진 데이터를 다른 스레드와 격리시킬 수 있어 충돌을 방지할 수 있습니다. 네트워크 요청이나 특정 데이터를 스레드별로 관리해야 할 때 유용합니다.

2. 읽기 전용 리소스

	•	안드로이드 앱에서 리소스 파일(XML, 이미지, 문자열 등)은 기본적으로 읽기 전용이기 때문에 이러한 리소스에 대해서는 동기화를 신경 쓸 필요가 없습니다. 또한, 불변 객체를 사용하면 여러 스레드가 안전하게 객체를 공유할 수 있습니다. 예를 들어, String 객체는 불변이므로 여러 스레드에서 안전하게 공유할 수 있습니다.

3. 원자성 연산

	•	안드로이드에서 AtomicInteger, AtomicBoolean, AtomicReference와 같은 클래스는 원자성을 보장하는 연산을 제공하므로, 간단한 상태 변수의 업데이트나 플래그 체크 등에 사용할 수 있습니다. 예를 들어, 네트워크 요청의 상태나 UI 업데이트를 관리할 때 이러한 클래스를 사용하면 동기화 문제를 피할 수 있습니다.

4. 동기화 및 상호 배제 (Mutual Exclusion in Synchronization)

	•	안드로이드에서는 synchronized 키워드를 사용하여 특정 코드 블록에 대해 상호 배제를 적용할 수 있습니다. 특히, 여러 스레드가 접근할 수 있는 공유 자원(예: 데이터베이스, 파일 등)을 다룰 때 유용합니다.
	•	더 복잡한 경우, ReentrantLock, Semaphore 같은 고급 동기화 메커니즘을 사용할 수 있으며, 이들은 복잡한 상호 배제 논리를 관리할 때 유용합니다.
	•	UI와 관련된 작업은 반드시 메인 스레드에서 처리되어야 하기 때문에 Handler, AsyncTask, Executor, Coroutine 같은 도구를 활용하여 안전한 스레드 간 통신 및 작업 분배를 관리할 수 있습니다.

5. 코루틴 (Coroutines) 및 비동기 처리

	•	Jetpack Compose나 최신 안드로이드 개발에서 코루틴을 사용하여 스레드 안전을 보다 간단하게 처리할 수 있습니다. 코루틴의 Dispatchers.Main과 Dispatchers.IO를 적절히 사용하면 UI 스레드와 백그라운드 작업 간의 상호작용을 안전하게 관리할 수 있습니다.
	•	withContext와 launch를 활용하면 특정 스레드에서 작업을 실행하고, 작업이 끝난 후 안전하게 결과를 받아올 수 있습니다.

---
