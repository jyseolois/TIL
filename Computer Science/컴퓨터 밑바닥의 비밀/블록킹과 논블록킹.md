# 블록킹과 논블록킹

동기와 비동기에는 항상 두 가지 대상이 언급되는데, 동기는 A와 B라는 두 대상이 강하게 결합된 것을 의미한다. 예를 들어 작업 A가 작업 B에 의존하는 경우이며, 이런 의존 관계가 존재할 때 A와 B는 동기이다. 반면, A와 B가 강한 결합과 같은 제약이 없어 각자 자신의 작업을 실행할 수 있을 때, A와 B는 비동기이다. 동기와 비동기를 언급할 때는 반드시 양쪽을 모두 의미한다. 

## 블로킹과 논블로킹
블로킹(blocking)과 논블록킹(non-blocking)은 프로그래밍에서 함수를 호출할 때 주로 사용된다. 함수 A와 함수 B가 있다고 가정하면 함수 A가 함수 B를 호출할 때, 함수 B를 호출함과 동시에 운영체제가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면, 함수 B에 대한 호출은 블로킹 방식이며, 그렇지 않으면 논블로킹 방식이다. 이처럼 블로킹 호출의 핵심은 스레드 또는 프로세스가 일시중지 되는것이다. 
물론 모두 함수 호출이 호출자의 스레드를 일시 중지시키는 것은 아니다. 
```
int sum(int a, int b) {
	return a + b;
}

void func() {
	int r = sum(1, 1);
}
```
fun 함수가 실행 중인 스레드는 sum 함수가 호출되더라도 운영체제가 이를 일시 중지시키지는 않는다. 그렇다면 함수 호출로 인해 호출자의 스레드나 프로세스가 운영 체제에 의해 일시 중지될 수 있는 경우는 어떤 경우일까?

## 블로킹의 핵심 문제: 입출력
일반적으로 블로킹은 대부분 입출력과 관련이 있다. 예를 들어 디스크의 경우에는, 일반적으로 하나의 트랙 탐색 입출력 요청을 완료하는 데 소요되는 시간은 ms 단위 수준이다. 반면에 CPU의 클럭 주파수(clock rate)는 이미 GHz 단위 수준에 도달해 있기 때문에, 디스크가 하나의 작업을 수행할 수 있는 ms 단위 시간이 CPU에 주어지면 대량의 기계 명령어 실행 작업을 수행할 수 있다. 따라서 일단 프로그램, 스레드 또는 프로세스가 이런 입출력 작업을 할 때는, 우리 스레드에서 입출력 과정이 실행되는 동안 CPU 제어권을 다른 스레드에 넘겨 다른 작업을 할 수 있도록 해야 한다. 이후 입출력 작업이 완료되면, 다시 CPU 제어권을 우리 스레드 또는 프로세스에 넘겨받아 계쏙 다음 작업을 실행할 수 있도록 한다. 이때 CPU 제어권을 상실했다가 되찾는 시간동안, 스레드나 프로세스는 블로킹되어 일시 중지된다. 스레드 A는 입출력 작업을 실행하여 블로킹되어서 일시 중지되며 CPU는 스레드 B에 할당된다. 스레드 B가 실행되는 동안 운영 체제는 입출력 작업이 완료된 것을 확인하면 다시 스레드 A에 CPU를 할당한다. 운영 체제는 CPU의 리소스를 최대한 활용할 수 있도록 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야 하는데, 이것이 바로 블로킹 입출력 방식이 필요한 핵심적인 이유이다. 

그 결과, 시간이 많이 걸리는 입출력 작업이 포함될 때 가끔 호출 스레드가 블로킹되며 일시중지되는 일이 발생한다. 이렇게 입출력 작업이 너무 느리다 보니, 관련 함수를 직접 호출하면 스레드 또는 프로세스가 블로킹되는 일이 발생한다. 호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작할 수 있는 방법은, 바로 논블로킹 호출을 사용하는 것이다. 

---

CPU는 매우 빠르게 작동한다. 예를 들어, CPU는 초당 수십억 개의 명령어를 처리할 수 있다. 반면에 디스크에서 데이터를 읽거나 네트워크를 통해 데이터를 주고받는 입출력 작업은 훨씬 느리다. 디스크에서 데이터를 읽는 데는 ms(밀리초) 단위의 시간이 걸리지만, CPU는 그 시간에 수백만 개의 명령어를 실행할 수 있다.

블로킹이 발생하는 이유

프로그램이 입출력 작업을 실행할 때 CPU는 할 일이 없어진다. 이 상황에서 CPU가 그냥 대기하고 있다면 낭비가 발생하기 때문에, CPU는 입출력 작업이 끝날 때까지 다른 작업(예: 다른 스레드 실행)에 사용된다.

블로킹이란 입출력 작업이 끝날 때까지, 그 작업을 요청한 스레드가 멈추는(대기하는) 것을 말한다. 이 스레드가 멈춘 사이, CPU는 다른 스레드나 작업에 할당된다. 이후 입출력 작업이 완료되면, CPU는 다시 원래 스레드로 돌아와 다음 작업을 처리하게 된다. 입출력 작업은 시간이 오래 걸리기 때문에, 그 작업이 완료될 때까지 CPU가 다른 스레드나 프로세스에 할당되고, 이 과정에서 호출한 스레드는 멈추게(블로킹) 되는 것이다. 입출력 작업이 끝나면, 다시 호출한 스레드가 CPU를 받아서 다음 작업을 이어가는 방식이다. 

한 마디로, 입출력 작업은 시간이 오래 걸리기 때문에, 그 작업이 완료될 때까지 CPU가 다른 스레드나 프로세스에 할당되고, 이 과정에서 호출한 스레드는 멈추게(블로킹) 되는 것이다. 입출력 작업이 끝나면, 다시 호출한 스레드가 CPU를 받아서 다음 작업을 이어가는 방식이다.

---

## 논블록킹과 비동기 입출력
네트워크 데이터 수신 함수인 recv가 논블록킹이면, 이 함수를 호출할 때 운영체제는 스레드를 일시 중지시키는 대신 recv 함수를 즉시 반환한다. 그리고 이후 호출 스레드는 자신의 작업을 계속 진행하며, 데이터 수신 작업은 커널이 처리한다. 이 두 가지 작업은 병행 처리된다. 데이터가 언제 수신했는지 알 수 있는 방법은 세 가지가 있다.
1. 논블로킹 방식의 recv 함수 외에 결과를 확인하는 함수를 함께 제공하고, 해당 함수를 호출하여 수신된 데이터가 있는지 확인할 수 있다. 
2. 데이터가 수신되면 스레드에 메세지나 신호 등을 전송하는 알림 작동 방식을 사용한다.
3. recv 함수를 호출할 때, 데이터 수신 처리를 담당하는 함수를 콜백 함수에 담아 매개변수로 전달할 수 있다. 이때 recv 함수는 콜백 함수를 지원해야 한다. 
이런 유형의 입출력 작업을 비동기 입출력(asynchronous input/output)이라고 한다. 블로킹 호출 방식과 비교해서 비동기 입출력 방식의 코드 작성은 그다지 작관적이지 않다. 

## 비유를 통한 블로킹과 논블로킹 
블로킹 호출은 피자 가게에 직접 가서 피자를 주문하는 것과 같다: 피자가 완성될 때까지 가게에서 기다려야 한다. 반면, 논블로킹 호출은 전화로 피자를 주문하는 것과 같다: 피자가 오기 전까지 다른 일을 할 수 있다.
논블로킹 호출 상황에서 피자가 완성되었는지는 다음과 같은 방법으로 알 수 있다: 1) 배달이 도착하면 전화가 오기 때문에 신경쓰지 않고 기다린다. 2) 5분마다 전화를 걸어 피자가 완성됐는지 물어본다. 이때 작업은 여전히 비동기이다. 3) 5분마다 전화는 일을 제외하고는 아무것도 하지 않는다 - 더이상 비동기가 아닌 동기이다. 즉, **논블로킹이 반드시 비동기를 의미하지는 않는다**. 

## 동기와 블로킹
- 동기는 블로킹과 다소 유사하다. 프로그래밍 관점에서 동기 호출은 반드시 블로킹이 아닌 반면에 블로킹 호출은 모두 확실한 동기 호출이다. 
```
int sum(int a, int b) {
    return a + b;
}
void funA() {
    sum(1, 1);
}
```
여기서 sum 함수에 대한 호출은 동기이지만, funA 함수가 sum 함수를 호출했다고 해서 블로킹되거나 스레드를 일시 중지되지는 않는다. 반면에 어떤 함수가 블로킹 방식으로 호출된 경우 반드시 동기 호출이다. 

## 비동기와 논블로킹
네트워크 데이터 수신을 예를 들어서, 데이터를 수신하는 recv 함수를 논블로킹 호출로 설정하기 위해 NON_BLOCKING_FLAG 설정값(flag)를 추가하면, 다음과 같이 네트워크 데이터를 수신할 수 있다.
```
void handler(void *buf) {
    // 수신된 네트워크 데이터를 처리한다.
    ...
}

while(true) {
    fd = accept();
    recv(fd, buf, NON_BLOCKING_FLAG, handler); // 호출 후 바로 반환, 논브로킹
}
```
이제 recv 함수는 논블로킹 호출이므로, 네트워크 데이터를 처리해주는 handler 함수를 recv 함수에 콜백으로 전달해야 한다. 따라서 앞의 코드는 비동기이자 논블로킹이다. 
그러나 시스템이 네트워크 데이터의 도착을 감지하는 전용 함수인 check 함수를 제공한다면, 이제 코드를 다음과 같이 변경할 수 있다.
```
void handler(void *buf) {
    // 수신된 네트워크 데이터를 처리한다.
    ...
}

while(true) {
    fd = accept();
    recv(fd, buf, NON_BLOCKING_FLAG); // 호출 후 바로 반환, 논블로킹

    while (!check(fd)) {
        // 순환 감지
        ;
    }
    
    handler(buf);
}
```
여기서도 recv 함수는 논블로킹으로 호출되지만, while 반복문에서 끊임없이 감지를 시도하여 데이터가 도착하기 전까지는 hanlder 함수를 사용할 수 없게 한다. 따라서 recv 함수는 비록 논블로킹이지만, 전체적인 관점에서 보면 . 이 코드는 동기이다. 이는 마치 전화로 피자를 주문했음에도 계속 전화로 끊임없이 확인하는 상황과 동일일하며, 이 상황은 동기이자 논블로킹에 해당한다. 앞선 코드는 반복문에서 CPU 리소스가 쓸데없이 소모되어 매우 비효율적이므로 이런 코드는 작성해서는 안 된다.
이처럼 논블로킹이더라도 전체적으로 반드시 비동기라는 의미는 아니며, 이는 코드 구현 방식에 따라 달라진다.

콜백 함수는 비동기 처리에 적용할 수 있고, 비동기는 스레드 및 프로세스와 밀접한 관계가 있다. 프로세스, 스레드, 코루틴과 동기, 비동기, 블로킹, 논블로킹을 이용하면 고성능 서버를 구현할 수 있다.

