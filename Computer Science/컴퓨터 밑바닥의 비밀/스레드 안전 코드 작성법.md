# 스레드 안전 코드는 어떻게 작성해야 할까

## 자유와 제약
- 스레드가 자신만의 전용 데이터를 사용한다면 스레드 안전(thread-safety)하다. 이런 데이터에는 함수의 지역 변수와 스레드 전용 저장소 등이 있으며, 전용 데이터를 사용하면 다른 스레드에는 영향을 미치지 않는다.
- 공유 리소스를 사용할 때는 다른 스레드에 영향을 주지 않도록 대기 제약 조건에 맞게 사용하면 스레드 안전을 달성할 수 있다.

## 스레드 안전이란
- 어떤 코드가 주어졌을 때, 그 코드가 스레드 몇 개에서 호출되든, 이 스레드들이 어떤 순서로 호출되든 간에 상관없이 올바른 결과가 나온다면, 이 코드를 스레드 안전하다고 말한다. 즉, 단일 스레드에서 실행되든 다중 스레드에서 실행되든 올바른 결과가 나와야 한다. 
- 스레드 안전 문제의 핵심은 어떤 것이 스레드 전용 리소스이고, 어떤 것이 공유 리소스인지 구분하는 데 있다.

## 스레드 전용 리소스와 공유 리소스
- 스레드 전용 리소스: 함수의 지역 변수, 스레드의 스택 영역, 스레드 전용 저장소
- 공유 리소스: 힙 영역(메모리의 동적 할당에 사용, C/C++의 malloc 함수와 new 예약어가 요청하는 메모리는 이 영역에 할당); 데이터 영역(전역 변수), 코드 영역(이 영역은 읽기 전용으로 프로그램이 실행되는 동안은 코드를 수정할 방법이 없으므로 신경쓸 필요가 없다)
- 따라서 스레드 공유 리소스는 힙 영역과 데이터 영역으로 구성된다.
- 이런 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 이 순서의 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것이다. 이를 위해 각종 잠금(lock)이나 세마포어(semaphore) 같은 장치를 사용할 수 있다. 이 규칙의 목적은 공유 리소스의 순서를 유지하는 것이다.

## 스레드 전용 리소스만 사용하기
- 어떤 함수가 전역 변수나 매개변수에 의존하지 않고 오로지 스레드 전용 리소스인 지역 변수만 사용한다면, 이런 코드를 무상태 함수(stateless function)이라고 하며, 이런 코드가 스레드 안전하다는 것은 분명하다. 지역 변수는 스레드의 스택 영역에서 관리된다.


## 함수 반환값
- 함수가 값을 반환하는 경우(return by value)와 함수가 포인터를 반환하는 경우(return by reference) 두 가지 경우가 있다.
- 값을 반환하는 경우는 스레드 안전하며, 어떤 스레드가 함수를 호출하든 똑같은 값을 반환한다. 반면 정적 지역 변수(static local variable)을 사용하는 함수의 경우 변수의 주소의 반환하기 때문에, 잠재적으로 스레드 공유 리소스가 되며, 해당 주소를 획득할 수 있는(포인터) 모든 스레드가 해당 변수를 수정할 수 있다. 단, 싱글톤 패턴(singleton pattern)을 구현할 수 있는 방법(instance 그 자체를 반환하는)은 있다. 

## 스레드 안전이 아닌 코드 호출하기
- 함수 A가 스레드 안전이 아닌 함수를 호출할 때 함수 A는 스레드 안전할까?
- 함수 B가 전역 변수를 사용하고 그 값을 수정한다면, 해당 함수는 스레드 안전이 아니다. 하지만 이 함수를 함수 A가 호출하기 전에 잠금으로 보호하면, 함수 B는 스레드 안전하다. 잠금으로 전역 변수를 간접적으로 보호하기 때문이다. 
- 매개변수로 전달된 포인터가 전역 변수를 가리키는지 아닌지 알 수 없을 때는 스레드 안전성을 알 수 없지만, 이 함수를 호출할 때 전달하는 변수가 스레드 전용 리소스인 지역 변수면 스레드 안전하다.
 
## 스레드 안전 코드 구현하기
- 스레드 안전 구현은 스레드 전용 리소스와 공유 리소스를 중심으로 진행된다. 스레드 안전을 달성하려면, 먼저 어떤 것이 스레드 전용 리소스이고 어떤 것이 스레드 공유 리소스인지를 파악하고, 그에 따라 조치를 취해야 한다.
- 스레드 전용 저장소(thread local storage): 전역 리소스를 사용해야 하는 경우 스레드 전용 저장소로 선언할 수 있는지 확인해 본다. 모든 스레드에서 사용할 수 있지만 각 스레드마다 자체 복사본이 있으며, 이를 변경하더라도 다른 스레드에는 영향을 미치지 않기 때문이다.
- 읽기 전용(read-only): 전역 리소스를 반드시 사용해야 한다면, 해당 전역 리소스를 읽기 전용으로 사용해도 되는지 확인해 본다. 
- 원자성 연산(atomic operation): 원자성 연산은 도중에 중단되지 않기 떄문에, 이런 변수에 대한 연산에는 전통적인 방식의 잠금으로 보호가 필요하지 않는다.
- 동기화 시 상호 배제(mutual exclusion in synchronization): 한 번에 하나의 스레드만 공유 리소스에 접근할 수 있도록 스레드가 접근하는 공유 리소스 순서를 프로그래머가 유지시켜 준다. 뮤텍스(mutex), 스핀 잠금(spin lcok), 세마포어(semaphore) 등 여러 가지 동기화 시 상호 배제를 위한 작동 방식 모두가 이 목적을 위해 사용될 수 있다.
- 커널 스레드(kernel thread): 스레드의 생성, 스케줄링, 종료를 모두 운영 체제가 수행한다. 프로그래머는 스레드가 어떻게 생성되고 스케줄링 되는지 전혀 관여할 수 없다. 운영 체제에 의존하지 않은 상황에서 직접 스레드를 구현하려면, 스레드보다 더 가벼운 실행 흐름인 코루틴으로 구현할 수 있다.

---

1. 스레드 전용 저장소 (Thread Local Storage)

	•	안드로이드에서 ThreadLocal 클래스를 사용하면 각 스레드마다 개별적인 데이터를 저장할 수 있습니다. 이 방법을 사용하면 특정 스레드가 가진 데이터를 다른 스레드와 격리시킬 수 있어 충돌을 방지할 수 있습니다. 네트워크 요청이나 특정 데이터를 스레드별로 관리해야 할 때 유용합니다.

2. 읽기 전용 리소스

	•	안드로이드 앱에서 리소스 파일(XML, 이미지, 문자열 등)은 기본적으로 읽기 전용이기 때문에 이러한 리소스에 대해서는 동기화를 신경 쓸 필요가 없습니다. 또한, 불변 객체를 사용하면 여러 스레드가 안전하게 객체를 공유할 수 있습니다. 예를 들어, String 객체는 불변이므로 여러 스레드에서 안전하게 공유할 수 있습니다.

3. 원자성 연산

	•	안드로이드에서 AtomicInteger, AtomicBoolean, AtomicReference와 같은 클래스는 원자성을 보장하는 연산을 제공하므로, 간단한 상태 변수의 업데이트나 플래그 체크 등에 사용할 수 있습니다. 예를 들어, 네트워크 요청의 상태나 UI 업데이트를 관리할 때 이러한 클래스를 사용하면 동기화 문제를 피할 수 있습니다.

4. 동기화 및 상호 배제 (Mutual Exclusion in Synchronization)

	•	안드로이드에서는 synchronized 키워드를 사용하여 특정 코드 블록에 대해 상호 배제를 적용할 수 있습니다. 특히, 여러 스레드가 접근할 수 있는 공유 자원(예: 데이터베이스, 파일 등)을 다룰 때 유용합니다.
	•	더 복잡한 경우, ReentrantLock, Semaphore 같은 고급 동기화 메커니즘을 사용할 수 있으며, 이들은 복잡한 상호 배제 논리를 관리할 때 유용합니다.
	•	UI와 관련된 작업은 반드시 메인 스레드에서 처리되어야 하기 때문에 Handler, AsyncTask, Executor, Coroutine 같은 도구를 활용하여 안전한 스레드 간 통신 및 작업 분배를 관리할 수 있습니다.

5. 코루틴 (Coroutines) 및 비동기 처리

	•	Jetpack Compose나 최신 안드로이드 개발에서 코루틴을 사용하여 스레드 안전을 보다 간단하게 처리할 수 있습니다. 코루틴의 Dispatchers.Main과 Dispatchers.IO를 적절히 사용하면 UI 스레드와 백그라운드 작업 간의 상호작용을 안전하게 관리할 수 있습니다.
	•	withContext와 launch를 활용하면 특정 스레드에서 작업을 실행하고, 작업이 끝난 후 안전하게 결과를 받아올 수 있습니다.

---
