# 콜백 함수

## 요구
만약 새로운 요청이 있을 때마다 함수 안에 if-else문이 추가되어야 한다면, 그때마다 코드를 계속 수정해야 하고, 이는 매우 잘못된 설계이다.

```
void make_donut() {
	if(CounA) {
		formed_A()
	} else if (Count) {
		formed_B()
	} else if….....
}
```

## 콜백이 필요한 이유
함수에 매개변수로 함수를 전달하도록 한다면 코드를 계속 수정할 필요가 없다. 이렇게 변수처럼 매개변수로 넘겨서 사용할 수 있는 함수는 ‘콜백 함수’이고, 일반적으로 콜백 함수는 직접 구현하지만 호출하는 것은 보통 다른 모듈이나 스레드이다.

```
void make_donut(fun f) {
	f()
}
// 콜백 함수
void formed_C() 
make_donut(formed_C);
```

## 비동기 콜백
만약 도넛 사업이 인기가 많아서 주문량이 증가하고 make_donut() 함수의 실행 시간도 점점 더 길어진다면 어떤 문제가 발생할까? 만약 해당 함수가 반환하는데 30분이 걸린다면, 그 밑의 함수가 실행되지 못하는 상황이 발생한다.

```
make_donut(formed_D);
something_important();
```

만약 이 줄이 너무 중요해서 30분 동안 기다릴 수 없다면 어떻게 이 문제를 개선할 수 있을까?

```
void real_make_donut(func f) {
	f();
}
void make_donut(func f) {
	thread t(real_make_donut, f);
}
```

make_donut 함수를 수정해서 함수 내부에서 스레드를 생성하고, 해당 스레드가 실제 도넛을 생성하게 할 수 있다. 이렇게 하면 이제 make_donut 함수를 호출하면 해당 함수는 새로운 스레드 t를 생성하고 나서 즉시 반환되고, 이후 something_important() 줄을 실행할 수 있다. 하지만 이때 중요한 점은, something_important() 줄의 코드가 실행 될 때 실제 도넛 생성 작업은 아직 시작되지 않았을 수 있다는 것이다. 이것이 바로 비동기(asynchronization)이다. 

이렇게 하면 make_donut 함수를 호출하고 나서 30분 동안 기다릴 필요가 없으며, 호출자와 피호출자가 각자의 스레드에서 병렬로 실행될 수 있다.

- 이처럼 **호출 스레드가 콜백 함수 실행에 의존하지 않는 것을 비동기 콜백(asynchronous callback)**이라고 한다. 

## 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다
- 보통 함수를 호출할 때는 1) 함수를 호출하고 결과를 획득하고, 2) 획득한 결과를 처리한다. 

```res = request(); 
handle(res)
```

- 이것은 바로 함수의 동기 호출(synchronous call)이며, request 함수가 반환한 결과를 획득해야 handle 함수를 호출하여 처리를 진행할 수 있다. 이때 request 함수가 반환되는 것을 무조건 기다려야 하는데 이것이 바로 동기 호출이다.
- 정보 관점에서 보면, 함수는 사실 호출자가 정보를 채워 넣기 전까지는 매개변수 정보가 무엇인지 알 수 없다. 컴퓨터 관점에서 보면, 정보에는 두 가지 유형이 있는데, 첫 번째 유형은 정수, 포인터, 구조체, 객체 등 데이터이며, 두 번째 유형은 함수 같은 코드이다. 따라서 프로그래머가 함수를 호출할 때 데이터 형태의 일반적인 변수 외에 코드로 된 함수 형태의 변수도 전달할 수 있다. 그렇게 때문에 handle 함수를 직접 호출하는 대신, reuqest 함수의 매개변수로 전달할 수 있다. 이제 handle 함수가 언제 호출 될지는 아예 신경 쓸 필요가 없으며, 이는 request 함수가 신경 써야 하는 부분이다. 
```
request(handle);
```
- 만약 이 함수 호출이 비동기 콜백이라면 request 함수는 즉시 반환될 수 있으며, 실제로 결과를 받아 처리하는 프로세스는 다른 스레드와 프로세스, 심지어는 다른 시스템에서 완료될 수 있다. 더 이상 언제 콜백이 실행되는지 관심을 가지지 않는 것이다. 
- 처리 흐름을 하나의 작업으로 생각할 때, 동기 호출 프로그래밍 방식에서는 함수를 호출한 스레드에서 전체 작업이 처리되는데 반해, 비동기 호출 프로그래밍 방식에서는 작업 처리가 두 부분으로 나뉜다: 1) 함수를 호출하는 스레드에서 처리 (request가 호출되기 전에 해당하는 부분) 2) 함수를 호출하는 스레드에서 처리되지 않고 다른 스레드, 프로세스 또는 다른 시스템에서 처리. 
- 이렇게 비동기 호출 프로그래밍 방식에서는 작업이 두 부분으로 나뉘어져 있기 때문에 두 번째 호출은 우리의 제어 범위에서 벗어나며, 이와 동시에 호출자만 무엇을 해야 할지 알고 있다. 
- 콜백 함수의 본질: 우리는 어떤 일을 해야 하는지 알지만, 이 일을 언제 하게 될지 정확히 알 수 없다. 반면에 다른 모듈은 언제 해야 할지는 알지만 무엇을 해야 할지는 모르기 때문에, 우리가 알고 있는 정보를 콜백 함수에 담아 다른 모듈에 전달해야 한다. 