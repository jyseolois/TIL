# 메모리의 본질, 포인터와 참조
CPU는 메모리의 도움 없이는 동작이 불가능하다. 이것은 사람의 뇌가 기억, 저장, 연산을 모두 담당하는 것과는 조금 다르다. 컴퓨터 시스템에서 연산을 담당하는 것은 CPU이고, 저장을 담당하는 것은 메모리이다.

메모리는 개념적으로 매우 단순해서 0과 1을 저장할 수 있는 사물함에 불과하다. 그러나 인류는 이 단순한 사물함에 힙 영역(heap segment), 스택 영역(stack segment), 데이터 영역(data segment), 가상 메모리(virtual memory), 메모리 할당(memory allocation), 메모리 해제(memory free), 메모리 누수(memory leak)과 같은 개념을 만들어냈다. 어떤 프로그래밍 언어로 프로그램을 작성하든지 모든 프로그램은 메모리에서 실행되어야 한다. 

## 메모리의 본질: 사물함, 비트, 바이트, 객체
메모리에서 파생된 개념: 바이트(byte), 구조체(structure), 객체(object), 변수(variable), 포인터(pointer), 참조(reference)

- 메모리는 사물함에 비유할 수 있다. 대신 메모리는 사물함 대신 메모리 셀(memory cell)이라는 표현을 사용한다.
- 비트: 메모리 셀에는 오직 0과 1만 보관할 수 있으며, 0 또는 1을 1비트(bit)라고 한다. 따라서 1비트는 0 또는 1이다. 1비트는 예 또는 아니요, 참(ture) 또는 거짓(false) 같은 대비되는 두 가지 정보만 표현할 수 있다.
- 바이트: 더 많은 정보를 표현하기 위해 비트 여덞 개를 묶어서 정보를 나타내는 하나의 단위인 1바이트(byte)를 사용한다. 따라서 모든 바이트는 메모리 내 자신의 주소를 가지고 있으며, 우리는 이 주소를 일반적으로 메모리 주소(memory address)라고 한다. 메모리 주소 한 개를 사용해서 특정한 사물함 여러 개를 찾을 수 있으며, 이를 주소 지정(addressing)이라고 한다. 하지만 1바이트 역시 8비트이기 때문에 정보를 표현하는 능력에는 한계가 있다. 8비트로 만들 수 있는 조합은 2^8인 256개에 불과하므로, 이를 부호 없는 정수(unsigned integer)로 표현하면 0부터 255까지 숫자만 표현 가능하다.
- 4바이트: 하지만 우리는 많은 것을 표현하기 위해 훨씬 큰 숫자가 필요하고, 일반적으로 4바이트를 묶어 하나의 정수를 표현하는 단위로 사용한다. 4바이트는 32비트로써 2^32개, 즉 4,294,967,296 개의 조합이 가능하기 때문에, 우리가 숫자를 표현하고자 할 때 충분히 대응할 수 있다. 이것이 C 언어와 같은 프로그래밍에서 int 형 변수의 크기가 4바이트인 이유이다.
- 구조체, 객체: 그러나 정수를 표현하는 것 외에도 정보 조합을 표현하고 싶을 수 있다. 여기서 각 항목은 정수에 해당하지만 동시에 이들은 모두 하나의 객체, 예를 들어 태진 정보에 해당한다. 이제 4바이트 메모리로는 충분하지 않으며, 서로 다른 정보 세 개를 표현하려면 12바이트가 필요하다. 이 12바이트를 사용해서 정보를 조합해서 표시하는 것을 프로그래밍 언어에서는 구조체(structure) 또는 객체(object)라고 표현한다.
- 컴퓨터는 0과 1만 이해할 수 있다: 프로그래밍 언어에서 사용되는 개념이 간단하든 복잡하든 상관없이 사물함에 저장되는 것은 0 또는 1이며, 모든 개념은 해석하기 나름이다. 8비트를 1바이트로 생각할 수 있고, 4바이트를 정수로 생각할 수 있으며, 연속된 메모리를 이용해서 구조체나 객체를 저장할 수도 있다. 하지만 메모리는 이것에 전혀 관심이 없으며, 메모리 안에 저장된 것은 어찌 되었든 모두 0 또는 1 뿐이다. 메모리 내 사물함에는 0 또는 1만 저장할 수 있으며, 따라서 컴퓨터는 0과 1만 이해할 수 있다. 

## 메모리에서 변수로: 변수의 의미
- 메모리 읽기와 쓰기의 본질: 본질은 메모리는 사물함이라는 사실을 인지하고 있어야 한다. 1바이트를 저장할 수 있는 사물함 여러 개가 하나로 묶여 있고, 각각 하나씩 번호가 붙어있는데, 이 번호가 바로 메모리 주소이다.
- 만약 1 + 2 값을 계산하고 싶다면, 먼저 숫자 1 과 숫자 2를 메모리에 저장해야 한다. CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 수행할 수 있기 때문이다. 
- 숫자 1과 숫자 2를 표현하기 위해 각각 1바이트를 사용한다고 가정하면, 먼저 이 두 숫자를 각각 사물함 두 개에 넣어야 한다. 그 중 숫자 1를 사물함 중 6번 사물함에 넣는다고 가정하자. 메모리에 정보를 저장할 때 store 명령어를 사용한다면, 숫자 1를 메모리에 저장하는 것은 다음과 같이 표현할 수 있다 :
```
Store $1 6
```
이 명령어에서 1과 6이라는 숫자 두 개를 볼 수 있는데, 모두 숫자라는 형식으로 되어 있지만 그 안의 의미는 서로 다르다. 하나는 저장할 숫자 값(data value)를 의미하고, 하나는 사물함 번호, 즉 메모리 주소를 의미한다. 쓰기에 대응하는 읽기를 위해 load 명령어를 사용한다고 가정하면, 그 형태는 다음과 같다.
-
```
load r1 6
```
$ 기호가 붙어 있으면 값이고 없다면 메모리 주소를 의미한다 - 값과 메모리 주소를 구분하기 위함이다.
이제 주소 6은 숫자 1을 나타낸다.
```
주소6 -> 숫자1
```
-
- 변수: 하지만 주소 6이라는 표현은 인간에게 익숙하지 않다. 따라서 주소 6에 a라는 별칭을 붙이면, a가 주소 6을 나타내게 되며, a에 저장된 값이 바로 1이 된다. 이것이 바로 변수다. 사람들은 이 정보를 다음과 같이 대수학을 이용한 직관적인 표현을 사용한다.
-
```
a = 1
```
표면상으로는 a 변수가 값 1과 동일한 것으로 보이지만, 그 뒤에 매우 중요한 정보를 감추고 있다는 것을 알 수 있다. 그 정보는 바로 a 변수가 숫자 1이 메모리 주소 6에 저장되어 있다는 것이다. 다시 말해 a 변수 또는 별칭 a의 뒤에는 다음과 같은 두 의미가 있다: 1) 값 1을 나타낸다. 2) 이 값은 메모리 주소 6에 저장된다.
-
```
b = a
```
a 값을 b에 준다는 이 할당을 메모리 관점에서 바라보면 어떤 의미를 지닐까? b 변수를 위해 사물함을 하나 할당해서 2번 사물함에 b변수를 저장했다고 가정하면, a 변수의 숫자 데이터를 완전히 복제 해서 2번 사물함에 넣을 수도 있다. 

- 구조체와 데이터: 만약 a 변수가 1바이트의 데이터뿐만 아니라, 구조체나 객체처럼 여러 바이트를 차지하는 데이터도 나타낼 수 있다고 가정하면, 이제 a 변수는 5바이트를 차지하며, 만약 이것이 메모리의 절반 이상에 해당하고, 이런 상황에서도 여전히 b = a를 표현해야 한다면 어떻게 해야 할까? 만약 이전처럼 데이터를 복사하는 방법을 사용하게 되면 메모리 공간이 부족하게 된다. 
- 포인터: 변수는 특정 값을 나타내고, 이 값은 특정 메모리 주소에 저장된다. 따라서 변수가 얼마나 많은 메모리 공간을 차지하고 있는지에 관계없이, 메모리 주소만 알고 있으면 해당 데이터를 찾을 수 있다. 또한 메모리 주소 역시 하나의 숫자로 이 역시 해당 데이터가 차지하고 있는 메모리 공간 크기와는 무관하다는 것도 알려준다. 그렇다면 b 변수도 a 변수를 가리키고 있다면, 굳이 불필요한 데이터의 복사본을 만들 필요없이, 그 주소만 저장하면 된다: a 변수는 메모리 주소 3에 위치하고 있으므로, b 변수에는 a의 값의 주소인 숫자 3을 저장할 수 있다. 이제 b 변수가 매우 흥미로워졌다. 저장하고 있는 숫자가 더 이상 값으로 해석되지 않고 메모리 주소로 해석되는 것이다. 이렇듯 **변수가 값 뿐만 아니라 메모리 주소까지 저장할 수 있게 되면서, 포인터(pointer)가 탄생했다.** 어셈블리어 수준에서 포인터는 주소 자체이지만, 고급 언어에서 포인터는 하나의 변수에 불과하다. 단지 이 변수가 저장하기에 적합한 것이 메모리 주소일 뿐이다. **포인터는 메모리 주소를 더 높은 수준으로 추상화한 것이다.**
- 간접 주소: 포인터를 메모리 주소로만 이해한다면 간접 주소 지정을 알아야 한다.
```
Load r1 @1
```
메모리 주소 1에 있는 값을 또 다른 메모리 주소로 해석을 원하기 때문에, 1에 @과 같은 식별자를 다시 한 번 추가해야 한다. 이러게 하면 이 명령어는 먼저 메모리 주소 1에 저장된 값인 3을 읽어 이 3이라는 값을 메모리 주소로 간주하여 해석한 후, 메모리 주소 3이 가리키는 값을 진짜 데이터로 간주한다. 이 값이 바로 a 변수가 나타내는 값이 되는 것이다.
```
주소1 -> 주소3 -> 데이터
```
이를 간접 주소 지정(indirect addressing)이라고 하며, 어셈블리어에는 변수라는 개념이 없기 때문에 어셈블리어를 사용한다면 반드시 이 간접 주소 지정 계층을 알고 있어야 한다.
반면에 고급 언어는 이와 다르게 변수 개념이 있는데, 이때 메모리 주소 1이 가리키는 것은 b 변수일 뿐이다. 변수를 사용할 때 가지는 장점 중 하나는 대부분 경우 b 변수에 메모리 주소 3이 저장되어 있다는 점에만 관심을 가지고, b 변수가 실제로 저장되는 위치가 어디인지는 관심을 가지지 않아도 괜찮다는 의미이다. 물론 이중 포인터를 사용할 때는 필요하지만, 어쨌든 b 변수를 사용할 때는 굳이 간접 주소 지정을 생각할 필요없이 오로지 b -> 데이터 이렇게 데이터를 직접 가리킨다고 생각하면 된다.
비교하자면 다음과 같다.
```
// 어셈블리어 수준
주소1 -> 주소 3 -> 데이터
// 고급 언어 수준
b -> 데이터
```
이것이 포인터를 더 높은 수준의 추상화라고 일컫는 이유이며, 이 추상화의 목적은 간접 주소 지정을 감싸기 위한 것이다.
이처럼 변수가 값과 메모리 주소를 모두 담을 수 있게 되면서 프로그래머가 복잡한 데이터 구조를 직접 처리할 수 있게 되었다. 

## 포인터의 힘과 파괴력: 능력과 책임
- 고급 프로그래밍에서의 포인터는 존재하지 않는다: 포인터를 지원하지 않는 프로그래밍 언어에서 c = a + b라는 코드를 작성할 때는 주소 개념이 없다. 이 주소라는 개념은 변수로 추상화되어 있기 때문에 a, b, c가 어디에 저장되는지 신경 쓸 필요 없이 이런 변수가 존재한다는 것만 알고 있으면 된다. 이 뜻은, 이런 프로그래밍 언어에서는 메모리 주소를 직접 노출하지 않기 때문에 메모리 주소를 확인할 수 없어 특정 메모리 위치에 있는 데이터를 직접 조작하는 것이 불가능하다. (Ex. 자바, 파이썬)
- C 언어에서의 포인터: 메모리 주소를 추상화하지 않고 훨씬 더 유연하므로 메모리 주소를 프로그래머가 직접 알 수 있다. 자바와 파이썬 같은 언어에서는 변수가 값만 저장할 수 있는 것처럼 보이는 반면에, C 언어에서는 값과 메모리 주소를 모두 저장할 수 있고, 이것이 바로 포인터이다. 포인터 개념이 있으면 프로그래머는 메모리 같은 하드웨어를 직접 조작할 수 있지만, 포인터 개념이 없는 프로그래밍 언어에서는 이런 작업이 불가능하다. 이것이 C 언어가 저수준 계층을 제어하는 강력한 힘을 가진 이유이자, C 언어가 시스템 프로그래밍에 가장 먼저 선택되는 중요한 원인이기도 하다. 변수 주소를 통해 해당 변수가 도대체 메모리 어느 위치에 저장되어 있는지 직접 확인할 수 있기 때문이다.
- 포인터가 있는 언어에서는 변수가 더 이상 모호한 개념이 아니라 매우 뚜렷한 개념이다:
```
# include <stdio.h>
void Main {
	int a = 1;
	printf(“variable a is in %p\n”, &a);
}
```
그럼 출력 값은 이렇게 나온다.
```
Variable a is In 0x7fffd8ca7954
```
변수 a의 메모리 주소 위치를 반환하는 것이다. 이처럼 변수가 구체적으로 메모리의 어느 위치에 저장되어 있는지 직접 확인이 가능할 정도로 뚜렷하고 명확하다. 다른 언어에서는 불가능하다. 

- 포인터로 메모리 주소를 알 수 있는 것은 강력한 능력이다: 모든 추상화를 우회하여 직접 메모리를 읽고 쓸 수 있는 반면에, 포인터 연산에 오류가 있을 때는 프로그램 실행 상태를 직접 파괴해 버릴 수 있다는 것을 의미한다. 포인터는 메모리르 ㄹ직접 조작할 수 있는 능력을 부여함과 동시에, 포인터를 조작할 때는 실수하지 않아야 한다는 더 높은 기준을 요구한다. 포인터를 잘못 다루면 프로그램 실행 시 오류가 쉽게 발생할 수 있으며, 이것이 프로그래머가 포인터를 기피하는 이유 중 하나이다.
- 참조: 그런데 사실 직접 메모리를 읽고 쓰는 이 기능이 모든 상황에 다 필요하지는 않을 뿐더러, 자바나 파이썬과 같은 언어에서는 포인터 없이도 프로그래밍으로 문제를 해결할 수 있다. 비록 이 언어에 포인터는 없지만, 포인터 대신 사용할 수 있도록 포인터를 한 번 더 추상화한 참조가 있기 때문이다. 

## 포인터에서 참조로: 메모리 주소 감추기
포인터를 지원하는 대신 참조(reference)라는 개념을 제공하는 프로그래밍 언어에서는 참조를 사용할 때는 변수의 구체적인 메모리 주소를 얻을 수 없으며, 참조는 포인터와 유사한 구조의 산술 연산을 할 수 없다. 메모리 위치에 값을 더하거나 빼면 각각의 메모리 주소에 저장되어 있는 데이터를 볼 수 있지만, 참조에는 이런 기능이 없기 때문에 산술 연산에 아무런 의미가 없다.
참조를 사용하면 데이터를 복사할 필요가 없기 때문에 포인터를 사용할 때와 동일한 효과를 얻을 수 있다. 간단히 요약하자면, 포인터는 메모리 주소를 추상화한 것이고, 참조는 포인터를 한 번 더 추상화한 것이다. 