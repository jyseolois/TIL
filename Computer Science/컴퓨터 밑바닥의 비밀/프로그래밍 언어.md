# 프로그래밍 언어

## CPU
- 간단한 스위치를 조합하면 복잡한 불 논리(boolean logic)을 표현할 수 있고, 이를 기반으로 CPU를 만들었다.
- CPU는 간단한 on-off(개폐)만 이해할 수 있으며, 이를 숫자로 표현하면 0과 1이 된다.
- CPU는 데이터를 한곳에서 다른 곳으로 옮기고, 간단히 연산한 후 다시 그 데이터를 또 다른 자리로 옮기는 작업밖에 할 줄 모를 정도로 단순하지만, 매우 빠르다.

## 바이너리 코드 (기계어)
- 처음에는 인간이 CPU가 이해할 수 있는 0과 1로 구성된 명령어를 작성했다 ㅡ 이것이 코드고, 소스다.   
- Binary(바이너리): 2진법을 의미하며, '1'과 '0'만으로 이루어진 2진수를 의미한다. 컴퓨터 시스템에서는 모든 데이터와 명령어를 전기적 신호(즉, 켜짐과 꺼짐)로 표현하며, 이를 위해 2진수를 사용한다. 이 두 상태를 나타내는 가장 기본적인 단위가 바로 비트(bit)이다. 8비트가 모여 1바이트(byte)가 되며, 컴퓨터는 이러한 비트와 바이트를 통해 데이터를 처리하고 저장한다.

- 바이너리 코드 (Binary Code): 바이너리 코드는 2진수(0과 1)의 조합으로 이루어진 코드로, 컴퓨터에서 데이터나 명령어를 표현하는 데 사용된다. 각 비트의 조합은 특정한 의미를 가지며, 예를 들어 문자를 표현할 때 ASCII나 유니코드와 같은 표준을 따른다. 프로그램이나 소프트웨어는 고수준 프로그래밍 언어로 작성된 후, 컴파일러에 의해 바이너리 코드로 변환되어 컴퓨터가 이해하고 실행할 수 있게 된다. 이 과정에서 생성되는 파일을 종종 바이너리 파일이라고도 한다.

- 기계어 (Machine Language): 기계어는 컴퓨터 프로세서가 직접 이해하고 실행할 수 있는 가장 낮은 수준의 프로그래밍 언어이다. 이 언어는 바이너리 코드로 작성되며, 각 명령어는 CPU가 수행해야 할 작업을 지정하는 특정 비트 패턴으로 구성된다. 현대 프로그래밍에서는 고수준 프로그래밍 언어를 사용한 후, 이를 기계어로 변환하는 컴파일러를 통해 프로그램을 작성하는 것이 일반적이다.

## 어셈블리어 등장
- CPU는 가산 명령어, 점프 명령어 등 겨우 몇 가지 명렁어만 실행할 수 있다는 사실을 발견하고, 기계어와 해당 특정 작업을 간단하게 대응시켜서 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시켰다. 이것이 어셈블리어(assembly language)의 탄생이다. 
- 어셈블리어(Assembly Language): 컴퓨터의 기계어를 인간이 이해하기 쉽게 표현한 저수준 프로그래밍 언어. 어셈블리어는 기계어 명령어를 사람이 이해할 수 있는 문자와 기호로 표현한 것이다. 어셈블리어는 저수준 언어로써 프로세서의 명령어 세트와 직접적으로 연관되어 있으며, 메모리 주소와 레지스터와 같은 하드웨어 자원을 직접적으로 다룰 수 있다. 또한  기계어와 1:1 대응이 되어 있어서, 어셈블리어의 각 명령어는 하나의 기계어 명령어에 직접 대응한다. 
- 어셈블리어는 특정 프로세서 아키텍처에 종속적이다. 즉, 특정 프로세서용으로 작성된 어셈블리어 코드는 다른 프로세서에서는 실행되지 않는다. 이는 x86, ARM, MIPS 등 서로 다른 아키텍처마다 고유의 어셈블리 언어가 있기 때문이다.
- 어셈블리어로 작성된 코드는 어셈블러(assembler)라는 소프트웨어를 통해 기계어로 번역된다. 이 과정에서 어셈블러는 어셈블리 코드를 각 프로세서가 이해할 수 있는 이진 명령어로 변환한다.

## 저수준 계층의 세부 사항 VS 고수준 계층의 추상화
- 어셈블리어는 여전히 저수준 언어이기 때문에, 이를 이용해서 프로그래밍을 하면 간단한 추상적인 표현 (ex. 저에게 물한잔 주세요)을 CPU가 알아들을 수 있는 세부 사항을 구체적으로 전부 나열해야 한다 (ex. 오른쪽 다리를 내딛는다, 멈춘다, 왼쪽 다리를 내 딛는다,  앞의 걸음을 음수대에 도착할 때까지 반복한다...) 
  
  어떻게 하면 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있을까?
- 세부 사항은 규칙으로 가득하다: **CPU에 특정 작업을 수행하라고 단도직입적으로 명령하는 문(statement)**, 특정 상황에 따라 어떤 명령어를 실행할지 말지를 결정하는 **if-else문(조건문)**, 명령어를 반복하는 **while문(반복문)**. 또한 개별적인 세부 사항만 차이가 있을 뿐 계속 반복되는 명렁어들이 있는데, 이런 차이를 매개변수(parameter)라고 하며, 이를 별도로 분리하고 매개변수를 제외한 명령어를 하나로 묶어 하나의 코드로 지정하면, **함수(function)** 가 탄생한다.

## 재귀: 코드의 본질
- Statement(문): 프로그램 내에서 특정 작업을 수행하는 단위. 각 Statement는 **하나의 명령이나 지시**를 나타내며, 프로그램의 실행 흐름을 제어한다. 예를 들어, **변수 선언, 할당, 조건문, 반복문, 함수 호출 등이 모두 Statement**에 해당한다. Statement는 실행 가능한 코드 조각으로, 프로그램의 논리를 구성한다.
- Syntax(구문): 프로그래밍 언어에서 **코드를 작성할 때 사용되는 문법 규칙**. 즉, Syntax는 코드가 올바르게 작성되어 컴파일러나 인터프리터가 이를 이해하고 실행할 수 있도록 하는 규칙 집합이다. Syntax는 코드의 구조와 형식을 정의하며, 올바른 Syntax를 따르지 않으면 코드가 에러를 일으키고 실행되지 않는다. **즉, Statement와 같은 코드 요소들이 어떻게 구성되어야 하는지를 정의**한다.
- **많은 코드가 반복적 구조(단계별로 중첩되는 계층적 구조)를 가지고 있으며, 따라서 본질적으로 재귀적이며 재귀적으로 표현할 수 있다.** 반복문과 재귀 호출은 서로 변환 가능하며, 반복적인 패턴을 처리하는 데 사용된다.
- 재귀 구문에 따라 작성된 코드를 트리(tree)구조로 표현할 수 있고, 이를 **구문 트리(syntax tree)** 라고 한다. 코드가 작성되면, **컴파일러나 인터프리터는 구문 트리를 생성하여 코드의 구조**를 분석한다. 구문 트리는 코드의 구문적 요소를 트리 구조로 표현하여 컴파일러가 코드의 의미를 이해하고 최적화할 수 있도록 한다.
- 구문 트리의 리프 노트(leap node)를 기계 명령어로 번역하면, 그 결과를 리프 노드의 부모 노드에 적용할 수 있다. 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다 보면, 결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있다.
- **컴파일러(compiler)** 는 이렇게 구문 트리를 사용해서 **인간이 작성한 프로그래밍 언어를 CPU가 인식할 수 있는 기계 명령어로 번역**하는 역할을 담당한다. 

## 해석형 언어의 탄생
- 각양각색의 CPU는 자신만의 고유한 언어가 있다. 한 CPU에서 생성된 기계 명렁어는 다른 CPU에서 실행할 수 없다는 문제가 생긴다.
- 프로그래머가 작성한 코드가 가능한 한 많은 플랫폼에서 실행되기를 원한다면, 표준 명령어 집합을 정의해서 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성해서 사용하면 된다.
- 이게 바로 CPU에 상응하는 가상 머신 (virtual machine) 또는 인터프리터(interpreter)이다.
  
### 컴파일러
- 컴파일러는 고수준 프로그래밍 언어(예: Java, C#)로 작성된 소스 코드를 바이트코드 또는 기계어로 변환해 주는 도구이다. 
  ㄴ 예를 들어, 자바 컴파일러(javac)는 자바 소스 코드를 자바 바이트코드로 컴파일한다. 이 바이트코드는 JVM에서 실행될 수 있는 형식이다.
  ㄴ 코틀린 컴파일러는 코틀린 소스 코드를 JVM 바이트코드로 컴파일한다. 이 바이트코드는 자바와 동일하게 JVM에서 실행되며, .class 파일 형식으로 저장된다.
- 즉, 컴파일러는 코드 변환의 일회성 작업을 수행하며, 변환된 결과물을 가상머신이나 하드웨어가 이해할 수 있는 형식으로 만든다.

### 가상머신 (Virtual Machine)
- 가상머신은 바이트코드를 실행할 수 있는 환경을 제공하는 소프트웨어이다.
 ㄴ 예를 들어, JVM(Java Virtual Machine)은 자바 바이트코드를 실행한다. JVM은 바이트코드를 해석하거나, JIT 컴파일러를 사용하여 실행 시점에 기계어로 변환하여 실행한다.
- 가상머신은 다양한 운영체제와 하드웨어 플랫폼에서 동일한 바이트코드를 실행할 수 있게 하여 플랫폼 독립성을 제공한다.
가상머신은 바이트코드를 실행하기 위해 두 가지 방법을 사용한다:
	1.	인터프리테이션(Interpretation): 가상머신이 바이트코드를 한 줄씩 읽고 해석하여 즉시 실행한다. 이 방식은 바이트코드를 직접 기계어로 변환하지 않고, 가상머신이 명령어를 해석하여 그에 맞는 동작을 수행한다.
	2.	JIT 컴파일(Just-In-Time Compilation): 실행 시점에 바이트코드를 기계어로 컴파일하여 실행한다. JIT 컴파일러는 바이트코드를 특정 하드웨어와 운영체제에 맞는 기계어로 변환한 후, 변환된 기계어를 실행한다. 이 방식은 일반적으로 성능을 높이는 데 사용된다.

## 정리
- 모든 프로그래밍 언어는 특정 구문에 따라 작성된다.
- 컴파일러는 언어 구문에 따라 코드 구문을 분석해서 구문 트리로 만들고, 이 구문트리를 기계 명령어로 번역해서 직접 CPU로 넘기거나, 자바처럼 바이트 코드(byte code)로 변환한 후 가상 머신으로 넘겨 실행한다.
- 고급 언어는 추상적 표현이 뛰어나서 사용하기 쉽지만, 저수준 계층에 대한 제어 능력이 떨어진다. 따라서 직접 저수준 계층의 세부 사항을 제어할 수 있어야 하는 운영 체제 중 일부분은 어셈블리어로 작성된다.