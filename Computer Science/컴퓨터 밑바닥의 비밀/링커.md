# 링커

- 링커는 컴파일러가 생성한 파일 여러 개를 묶어 하나의 실행 파일을 생성한다.
- 소스 코드를 담고 있는 파일을 컴파일하면 기계 명렁어에 해당하는 코드를 저장하는 파일이 생성되는데, 이 파일을 대상 파일(.o, object file)이라고 한다. 

## 링커는 이렇게 일한다
- 심벌 해석(symbol resolution): 링커는 모듈 사이의 종속성(dependency)가 올바르게 설정되어 있는지, 즉, 인터페이스 구현이 종속된 모듈에서 사용 가능한지 확인한다. 우리가 참조하고 있는 외부 심벌(external symbol)에 대한 실제 구현이 어느 모듈이든지 단 하나만 있어야 하고, 링커는 이를 찾아내 연결하는 작업을 하는 것이다.
- 실행 파일 생성: 링커는 대상 파일을 모두 모아 하나의 실행 파일로 만든다.
- 재배치(relocation): 한 소스 파일에서 다른 모듈에 정의되어 있는 함수를 참조할 때, 컴파일러가 소스 파일을 컴파일하는 시점에는 함수가 어느 메모리 주소(memory address)에 위치할지 정확하게 알 수 없기 때문에 일단은 N으로 표시해두고 넘어가면, 링커가 이런 표시들을 확인하고 한데 모아 실행 파일을 생성하는 과정에서 함수의 정확한 주소를 확인하고 실제 메모리 주소로 대체해 준다.

## 심벌 해석: 수요와 공급
- 심벌(symbol): 전역 변수(global variable)과 함수(function)의 이름을 포함하는 모든 변수의 이름. 단, 지역 변수(local variable)은 모듈 내에서만 사용되어 외부 모듈에서 참조할 수 없기 때문에, 링커의 관심 대상이 아니다.
- 링커는 대상 파일에서 참조하고 있는 각각의 모든 외부 심벌마다 대상 정의가 반드시 존재하는지, 또, 단 하나만 존재하는지 확인해야 한다.
- 컴파일러는 인간이 이해할 수 있는 코드를 기계 명령어로 생성할 때 이 명령어를 실행시키는 데이터도 생성해서 대상 파일에 포함시킨다. 즉, 대상 파일은 두 가지 부분으로 나뉜다:
  1) 코드 영역(code section): 명령어 부분. 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분.
  2) 데이터 영역(data section): 소스 파일의 전역 변수가 저장되는 부분. (로컬 변수는 프로그램이 실행된 후 스택 영역에서 생성되고 사용하면 제거되기 때문에, 대상 파일에는 별도로 저장되지 않는다)
  3) 심벌 테이블(symbol table): 소스 파일마다 외부에서 참조 가능한 심벌이 어떤 것인지(해당 소스 파일이 정의한 심벌), 또한 반대로 어떤 외부 심벌을 침조하고 있는지(해당 소스 파일이 사용하는 외부 심벌)에 대한 정보를 표에 기록한다. 
- 링커는 각 대상 파일에서 사용할 외부 심벌이 심벌 테이블에서 유일한 정의(unique definition)를 발견 가능한지 확인하는 작업을 담당하는데, 이게 바로 심벌 해석이다. 참조된 변수나 함수 정의를 찾는 것이다. 
- 만약 심벌에 대한 참조가 없으면, 즉, 어떤 함수가 참조되었지만 정의되지 않았다면, 링커는 오류를 발생시킨다.

## 정적 라이브러리, 동적 라이브러리, 실행 파일
- 라이브러리: 특정 기능을 구현한 코드의 집합체로, 다른 프로그램에서 재사용할 수 있도록 만든 것. 라이브러리는 크게 정적 라이브러리와 동적 라이브러리로 나눌 수 있으며, 각각의 특징과 장단점이 있다.
  
#### 정적 라이브러리
- 정적 라이브러리 (Static Library): 컴파일 타임에 프로그램에 포함되어 실행 파일의 일부분이 되는 라이브러리. 주로 .lib (Windows) 또는 .a (Unix 계열) 확장자를 가진다. 정적 라이브러리를 사용하면, 컴파일러는 라이브러리를 실행 파일에 복사하여 포함시킨다. 실행 파일을 생성할 때 미리 컴파일이 완료된 정적 라이브러리는 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제된다.
- 정적 링크 (static link): 컴파일 타임에 정적 라이브러리와 오브젝트 파일(대상 파일)의 코드를 실행 파일에 포함시키는 과정이다. 이 과정에서는 링커가 각 정적 라이브러리와 오브젝트 파일에서 필요한 코드를 추출하여 하나의 실행 파일로 합친다. 코드가 의존하는 외부 코드를 매번 컴파일하지 않아도 되기 때문에 컴파일 속도가 빨라진다.
- 정적 링크는 정적 라이브러리와 대상 파일(오브젝트 파일)을 한데 모아 각각의 파일에서 데이터 영역과 코드 영역을 결합한다. 실행 파일에도 코드 영역과 데이터 영역이 있으며, 또한 특수한 심벌인 _start가 존재한다. CPU는 이 심벌 주소에서 프로그램을 실행하는 데 필요한 기계 명령어를 찾고 실행한 후에야 비로소 main 함수를 실행하기 시작한다.
- 정적 라이브러리의 장점: 
  1. 독립성: 실행 파일이 외부 의존성 없이 독립적으로 동작할 수 있다.
	1. 성능: 실행 시 동적 라이브러리를 로드할 필요가 없어 약간의 성능 이점을 가질 수 있다.
	2. 안정성: 라이브러리가 프로그램에 포함되므로, 라이브러리 버전이 변경되거나 삭제되더라도 프로그램의 동작에 영향을 미치지 않는다.
- 정적 라이브러리의 단점:
	1. 중복 데이터: 모든 프로그램에 적용되는 표준 라이브러리를 사용한다면, 정적 링크로 생성된 실행 파일은 모두 동일한 코드와 데이터의 복사본을 갖게 된다. 즉, 정적 라이브러리를 사용하는 실행 파일은 모두 중복된 데이터를 가진다.
	2. 재컴파일 필요: 정적 라이브러리의 코드가 변경될 때마다 해당 라이브러리에 종속된 프로그램을 다시 컴파일해야 한다.
	3. 파일 크기 증가: 모든 정적 라이브러리가 실행 파일에 포함되므로, 실행 파일의 크기가 커질 수 있다.

동적 라이브러리 (Dynamic Library)
동적 라이브러리는 정적 라이브러리의 단점을 보완하기 위해 사용됩니다. 동적 라이브러리는 실행 시에 프로그램에 로드되며, 프로그램과 독립적으로 존재하는 라이브러리입니다. 보통 .dll (Windows) 또는 .so (Unix 계열) 확장자를 가집니다.
특징
	•	파일 크기 감소: 실행 파일에 라이브러리를 포함하지 않으므로, 실행 파일의 크기가 작아집니다.
	•	업데이트 용이성: 라이브러리를 독립적으로 업데이트할 수 있어, 프로그램을 재컴파일하지 않고도 라이브러리의 버그 수정이나 기능 추가가 가능합니다.
	•	메모리 절약: 여러 프로그램이 동일한 동적 라이브러리를 공유하여 메모리 사용량을 줄일 수 있습니다.
단점
	1.	의존성 문제: 실행 파일이 필요한 라이브러리를 찾지 못하면 프로그램이 실행되지 않을 수 있습니다.
	2.	복잡성 증가: 다양한 버전의 라이브러리 관리가 복잡해질 수 있습니다.
	3.	성능 저하: 라이브러리를 로드하는 데 시간이 걸릴 수 있으며, 이로 인해 약간의 성능 저하가 발생할 수 있습니다.

결론
정적 라이브러리와 동적 라이브러리는 각각의 장단점이 있으며, 다양한 상황에서 사용될 수 있습니다. 정적 라이브러리는 독립적으로 실행할 수 있고 성능상의 이점을 제공하지만, 파일 크기 증가와 재컴파일 필요성 등의 단점이 있습니다. 반면, 동적 라이브러리는 파일 크기를 줄이고 업데이트를 용이하게 하지만, 의존성 문제와 성능 저하의 단점이 있습니다.