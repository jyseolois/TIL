# 블록킹과 논블록킹

동기와 비동기에는 항상 두 가지 대상이 언급되는데, 동기는 A와 B라는 두 대상이 강하게 결합된 것을 의미한다. 예를 들어 작업 A가 작업 B에 의존하는 경우이며, 이런 의존 관계가 존재할 때 A와 B는 동기이다. 반면, A와 B가 강한 결합과 같은 제약이 없어 각자 자신의 작업을 실행할 수 있을 때, A와 B는 비동기이다. 동기와 비동기를 언급할 때는 반드시 양쪽을 모두 의미한다. 

## 블로킹과 논블로킹
블로킹(blocking)과 논블록킹(non-blocking)은 프로그래밍에서 함수를 호출할 때 주로 사용된다. 함수 A와 함수 B가 있다고 가정하면 함수 A가 함수 B를 호출할 때, 함수 B를 호출함과 동시에 운영체제가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면, 함수 B에 대한 호출은 블로킹 방식이며, 그렇지 않으면 논블로킹 방식이다. 이처럼 블로킹 호출의 핵심은 스레드 또는 프로세스가 일시중지 되는것이다. 
물론 모두 함수 호출이 호출자의 스레드를 일시 중지시키는 것은 아니다. 
```
int sum(int a, int b) {
	return a + b;
}

void func() {
	int r = sum(1, 1);
}
```
fun 함수가 실행 중인 스레드는 sum 함수가 호출되더라도 운영체제가 이를 일시 중지시키지는 않는다. 그렇다면 함수 호출로 인해 호출자의 스레드나 프로세스가 운영 체제에 의해 일시 중지될 수 있는 경우는 어떤 경우일까?

## 블로킹의 핵심 문제: 입출력
일반적으로 블로킹은 대부분 입출력과 관련이 있다. 예를 들어 디스크의 경우에는, 일반적으로 하나의 트랙 탐색 입출력 요청을 완료하는 데 소요되는 시간은 ms 단위 수준이다. 반면에 CPU의 클럭 주파수(clock rate)는 이미 GHz 단위 수준에 도달해 있기 때문에, 디스크가 하나의 작업을 수행할 수 있는 ms 단위 시간이 CPU에 주어지면 대량의 기계 명령어 실행 작업을 수행할 수 있다. 따라서 일단 프로그램, 스레드 또는 프로세스가 이런 입출력 작업을 할 때는, 우리 스레드에서 입출력 과정이 실행되는 동안 CPU 제어권을 다른 스레드에 넘겨 다른 작업을 할 수 있도록 해야 한다. 이후 입출력 작업이 완료되면, 다시 CPU 제어권을 우리 스레드 또는 프로세스에 넘겨받아 계쏙 다음 작업을 실행할 수 있도록 한다. 이때 CPU 제어권을 상실했다가 되찾는 시간동안, 스레드나 프로세스는 블로킹되어 일시 중지된다. 스레드 A는 입출력 작업을 실행하여 블로킹되어서 일시 중지되며 CPU는 스레드 B에 할당된다. 스레드 B가 실행되는 동안 운영 체제는 입출력 작업이 완료된 것을 확인하면 다시 스레드 A에 CPU를 할당한다. 운영 체제는 CPU의 리소스를 최대한 활용할 수 있도록 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야 하는데, 이것이 바로 블로킹 입출력 방식이 필요한 핵심적인 이유이다. 

그 결과, 시간이 많이 걸리는 입출력 작업이 포함될 때 가끔 호출 스레드가 블로킹되며 일시중지되는 일이 발생한다. 이렇게 입출력 작업이 너무 느리다 보니, 관련 함수를 직접 호출하면 스레드 또는 프로세스가 블로킹되는 일이 발생한다. 호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작할 수 있는 방법은, 바로 논블로킹 호출을 사용하는 것이다. 

---

CPU는 매우 빠르게 작동한다. 예를 들어, CPU는 초당 수십억 개의 명령어를 처리할 수 있다. 반면에 디스크에서 데이터를 읽거나 네트워크를 통해 데이터를 주고받는 입출력 작업은 훨씬 느리다. 디스크에서 데이터를 읽는 데는 ms(밀리초) 단위의 시간이 걸리지만, CPU는 그 시간에 수백만 개의 명령어를 실행할 수 있다.

블로킹이 발생하는 이유

프로그램이 입출력 작업을 실행할 때 CPU는 할 일이 없어진다. 이 상황에서 CPU가 그냥 대기하고 있다면 낭비가 발생하기 때문에, CPU는 입출력 작업이 끝날 때까지 다른 작업(예: 다른 스레드 실행)에 사용된다.

블로킹이란 입출력 작업이 끝날 때까지, 그 작업을 요청한 스레드가 멈추는(대기하는) 것을 말한다. 이 스레드가 멈춘 사이, CPU는 다른 스레드나 작업에 할당된다. 이후 입출력 작업이 완료되면, CPU는 다시 원래 스레드로 돌아와 다음 작업을 처리하게 된다. 입출력 작업은 시간이 오래 걸리기 때문에, 그 작업이 완료될 때까지 CPU가 다른 스레드나 프로세스에 할당되고, 이 과정에서 호출한 스레드는 멈추게(블로킹) 되는 것이다. 입출력 작업이 끝나면, 다시 호출한 스레드가 CPU를 받아서 다음 작업을 이어가는 방식이다. 

한 마디로, 입출력 작업은 시간이 오래 걸리기 때문에, 그 작업이 완료될 때까지 CPU가 다른 스레드나 프로세스에 할당되고, 이 과정에서 호출한 스레드는 멈추게(블로킹) 되는 것이다. 입출력 작업이 끝나면, 다시 호출한 스레드가 CPU를 받아서 다음 작업을 이어가는 방식이다.

---

## 논블록킹과 비동기 입출력
네트워크 데이터 수신 함수인 recv가 논블록킹이면, 이 함수를 호출할 때 운영체제는 스레드를 일시 중지시키는 대신 recv 함수를 즉시 반환한다. 그리고 이후 호출 스레드는 자신의 작업을 계속 진행하며, 데이터 수신 작업은 커널이 처리한다. 이 두 가지 작업은 병행 처리된다. 데이터가 언제 수신했는지 알 수 있는 방법은 세 가지가 있다.
1. 논블로킹 방식의 recv 함수 외에 결과를 확인하는 함수를 함께 제공하고, 해당 함수를 호출하여 수신된 데이터가 있는지 확인할 수 있다. 
2. 데이터가 수신되면 스레드에 메세지나 신호 등을 전송하는 알림 작동 방식을 사용한다.
3. recv 함수를 호출할 때, 데이터 수신 처리를 담당하는 함수를 콜백 함수에 담아 매개변수로 전달할 수 있다. 이때 recv 함수는 콜백 함수를 지원해야 한다. 
이런 유형의 입출력 작업을 비동기 입출력(asynchronous input/output)이라고 한다. 블로킹 호출 방식과 비교해서 비동기 입출력 방식의 코드 작성은 그다지 작관적이지 않다. 