# 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
메모리 내 프로세스 구조는 다음과 같다:
커널
스택 영역(함수 실행 시 정보 저장)
힙 영역(동적 메모리 할당)
데이터 영역
코드 영역
메모리의 모든 프로세스는 이런 모습을 하고 있다. 모든 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 코드 영역(code segment)와 데이터 영역(data segment)은 실행 파일을 초기화할 때 생성되는 영역이다. (코드 영역 - 앱 실행 시 로드된 프로그램 명령어 저장. 데이터 영역-  프로그램 실행 중 필요한 전역 변수와 정적 변수를 저장. 클래스 로딩 시 object 키워드나 companion object로 선언된 변수들이 이 영역에 저장)
- 힙 영역(heap segment)은 동적 메모리 할당에 사용되는데, 구체적으로 C/C++ 언어의 malloc 함수에서 요청한 메모리가 이 힙 영역에 할당된다. (앱이 실행 중에 필요에 따라 생성하는 객체와 데이터를 저장하는 데 사용. 즉, 안드로이드 앱에서 동적으로 생성되는 객체들은 모두 힙 영역에 저장. 예를 들어 User 클래스나 List 객체는 실행 중에 동적으로 생성되므로 힙에 할당)
- 스택 영역(stack segment)은 함수 호출에 사용되며 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장하는 데 사용된다. (함수 실행 시 생성되는 지역 변수와 함수 호출 정보가 이곳에 저장)
- => 코드 영역은 코드의 로직 그 자체(방법)을 저장하고, 실행 중 생성되고 변화하는 데이터는 다른 메모리 영역(데이터, 힙, 스택)에 나뉘어 관리

## 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다
프로세스 주소 공간 구조에서 흥미로운 점은 모든 프로세스의 코드 영역이 0x400000에서 시작하며, 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 malloc 함수를 호출하면 둘 다 0x7f64cb8을 반환하는 등 동일한 시작 주소를 반환할 가능성이 매우 높다. 그렇다면 이 두 프로세스가 모두 주소 0x7f64cb8에 데이터를 쓸 수 있다는 건데 이것이 문제되지는 않을까? 문제되지 않는다. 왜냐면 0x7f64cb8라는 메모리 주소는 가짜 주소이며, 이 주소는 메모리에 조작이 이렁나기 전에 실제 물리 메모리 주소에 변경된다. 다시 말해 코드, 데이터, 힙, 스택 같은 구조는 가상적인 구조에 불과하고, 실제 메모리에는 애초에 이런 형태의 구조가 존재할 수 없다. 오히려 실제 물리 메모리의 모습은 각 프로세스의 영역이 조각으로 나뉘어져 중구난방으로 흩어져 있는 모습에 훨씬 가깝다. 즉, 실제 물리 메모리에서는 프로세스는 동일한 크기의 조각(chunck)로 나뉘어 물리 메모리에 저장된다 (ex. 프로세스의 힙 영역이 동일한 크기의 조각 x개로 나뉘어져 있다 - 힙 영역 파트1, 힙 영역 파트 2…), 그리고 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다. 이런 물리 메모리와 가상 메모리 사이에는 사상(mapping) 관계가 있고, 페이지 테이블(page table)이 존재한다.

## 페이지와 페이지 테이블: 가상에서 현실로
가상 메모리 주소 공간은 물리 메모리에 매핑되어 있다. 가상 메모리 주소와 물리 메모리 주소의 매핑 관계가 유지되는 한, 프로세스 주소 공간의 데이터가 실제 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다. 이런 사상 관계(maaping)을 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 한다. 여기서 주목할 만한 것은 모든 가상 주소를 물리 주소에 사상하는 대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 페이지(page)라고 부른다는 점이다. 이처럼 사상은 페이지 단위로 이루어지므로, 페이지 테이블이 가져야 하는 항목 수가 대폭 줄어든다. 이제 두 프로세스가 동일한 메모리 주소에 기록하더라도 문제가 발생하지 않는 이유를 알 수 있다. 이 메모리 주소가 가르키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문이다. (Ex. 프로세스 A 코드 영역 Part 2, 프로세스 B 코드 영역 Part 2). 따라서 표준적이고 깔끔하게 정리된 가상 주소 공간은 현실에는 존재하지 않으며, 단지 논리적인 표현에 불과하다. 이것이 바로 최신 운영 체제에서 매우 중요한 기능인 가상 메모리의 기본 구현 원리이다.

# 스택 영역: 함수 호출은 어떻게 구현될까?
함수 실행 시간 스택(runtime stack) 또는 함수 호출 스택(call stack)을 먼저 이해해 보자.

### 프로그래머를 위한 도우미: 함수
동일한 기능을 하는 코드는 매번 반복해서 작성할 필요가 없도록 함수에 담아 둘 수 있다. 함수는 가장 기초적이고 간단한 코드 재사용 방식이다. 또한 함수는 프로그래머가 구현의 세부 사항을 감출 수 있게 하므로, 함수를 호출할 때는 함수 이름, 매개변수, 반환값만 알면 된다. 함수가 어떻게 구현되어 있는지는 전혀 신경 쓸 필요가 없으며, 이 역시 일종의 추상화에 해당한다. 그렇다면 함수의 호출은 어떻게 구현된 것일까?

### 함수 호출 활동 추적하기: 스택
스택 상단의 작업 궤적은 후입선출(last in first out)의 순서로, 본질적으로 스택과 같은 데이터 구조가 처리하기에 적합하다. 또한 사실상 이진 트리(binary tree)의 탐색(search)이라는 것도 알 수 있다. 이것이 리너 트리 구조의 순회가 재귀 구현 뿐만 아니라 스택 구현에도 사용될 수 있는 이유이다.

### 스택 프레임 및 스택 영역: 거시적 관점
모든 함수는 실행 시에 자신만의 작은 상자가 필요하다. 이 상자 안에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 이 상자들은 스택 구조를 통해 구성된다. 여기에서 각각의 작은 상자를 스택 프레임(stack frame)또는 호출 스택(call stack)이라고 한다. 그리고 이 구조는 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다. 프로세스 스택 영역의 높은 주소(highest address)가 맨 위에 있고, 스택 영역은 낮은 주소 방향으로 커진다. 다시 말해, 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고, 함수 호출이 완료될수록 감소한다. 그렇다면 스택 프레임이라는 이 작은 상자 안에는 무엇이 들어 있을까? 이 질문에 답하려면 함수를 호출할 때 어떤 정보들이 포함되는지 이해해야 한다. 

### 함수 점프와 반환은 어떻게 구현될까?
함수 A가 함수 B를 호출하면 제어권이 함수 A에서 함수 B로 옮겨지고, 여기에서 제어권은 실제로 CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지를 의미한다. CPU가 함수 A의 명령어를 실행하다가 함수 B의 명령어로 점프하는 것을 제어권이 함수 A에서 함수 B로 이전되었다고 이야기한다. 제어권이 이전될 때는 다음 두 가지 정보가 필요하다: 반환(return) 즉, 어디에서 왔는지에 대한 정보. 그리고 점프(jump) 즉, 어디로 가는지에 대한 정보. 다시 말해, 함수 A가 함수 B를 호출할 때 함수 A의 기계 명령어가 어디까지 실행되었는지(어디에서 왔는지), 그리고 함수 B의 첫 번째 기계 명령어가 위치한 주소(어디로 가는지)를 알아야 한다. 이 두 가지 정보만 있으면, CPU에 함수 A에서 함수 B로 점프하여 명령어를 실행하게 한 후, 함수 B의 실행이 완료되면 다시 함수 A로 점프하게 할 수 있다. 바로 이런 정보가 스택 프레임에 담기는 것이다. 예를 들어 함수 A가 함수 B를 호출할 때 CPU가 함수 A의 기계 명령어를 실행하고 있다가 call 0x400540 같은 기계 명령어를 만나면 이에 대응하는 것은 코드의 함수 호출이므로 함수 B의 첫 번째 기계 명령어 주소인 함수 B의 0x400540로 CPU는 점프하게 된다. 또한 call 명령어 다음에 위치한 주소를 함수 A의 스택 프레임에 넣는다. 이것이 바로 함수 A의 반환주소이다. 즉, CPU는 함수 B의 대응하는 기계 명령어를 실행하기 시작하면 함수 B를 위한 새로운 스택 프레임이 추가되고 스택 영역이 차지하는 메모리 크기도 증가하는데, 함수 B의 마지막 기계 명령어인 ret까지 계속 실행한 다음 이 기계 명령어에 따라 CPU에 함수 A의 스택 프레임에 저장된 반환 주소로 점프한다. 이에 따라 함수 B의 실행이 완료되면, 바로 함수 A로 점프하여 계속 실행할 수 있다. 함수 A의 스택 프레임에 저장된 주소는 0x40056a이며, 이는 함수 A의 call 명령어 바로 다음 기계 명령어의 주소에 해당한다. 함수의 반환 주소 외에 또 어떤 정보가 스택 프레임에 저장될까?

### 매개변수 전달과 반환값은 어떻게 구현될까?
CPU는 기계 명령어를 실행할 때 점프와 반환이 가능하기 때문에 이를 이용해서 함수를 호출할 수 있었다. 하지만 함수를 호출할 때는 함수 이름 외에도 매개변수를 전달하고 반환값을 가져와야 한다. 이를 어떻게 구현할 수 있을까? X86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다. 함수 A가 함수 B를 호출한다면, 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다. 마찬가지로 함수 B도 반환값을 레지스터에 저장하고, 함수 B의 실행이 완료되면 이 레지스터에서 반환값을 가져올 수 있다.

그런데 CPU 내부의 레지스터 수는 제한되어 있다. 만약 전달된 매개변수 수가 사용 가능한 레지스터 수보다 많다면 어떻게 해야 할까? 함수가 가지고 있는 작은 상자인 스택 프레임이 다시금 힘을 발휘할 순간이다. 원래 매개변수 수가 레지스터 수보다 많으면 나머지 매개변수는 스택 프레임에 직접 넣을 수 있기 때문에, 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져오면 된다. 즉, 스택 프레임은 함수 호출에 필요한 매개변수를 보관한다. 함수 B를 호출할 때 매개변수 중 일부를 함수 A의 스택 프레임에 넣는 것이다.

### 지역 변수는 어디에 있을까?
함수 외부에 정의된 변수를 전역 변수라고 한다. 이 변수들은 실행 파일의 데이터 영역에 저장되어 있다가 프로그램이 실행되면 프로세스 주소 공간의 데이터 영역에 적재된다. 반면에, 함수 내부에서 정의된 변수는 지역 변수라고 하는데, 이 변수들은 해당 함수에서만 사용 가능하고 외부에서는 접근이 불가능하다. 이 지역변수들은 마찬가지로 레지스터에 저장될 수 있지만, 로컬 변수 수가 레지스터 수보다 많으면 이 변수들도 스택 프레임에 저장되어야 한다.

### 레지스터의 저장과 복원
그렇다면 레지스터는 CPU의 내부 리소스인데, CPU가 함수 A를 실행할 때 이런 레지스터를 사용하고 CPU가 함수 B를 실행할 때도 마찬가지로 이 레지스터를 사용한다면, 함수 A가 함수 B를 호출할 때 함수 A가 레지스터에 기록한 지역 변수 정보를 함수 B가 덮어써서 문제가 될 수도 있다. 따라서 레지스터에 지역 변수를 저장하게 전에, 반드시 먼저 레지스터에 원래 저장되었던 초깃값을 꺼냈다가 레지스터를 사용하고 나면 다시 그 초깃값을 저장해야 한다. 레지스터에 원래 저장되어 있던 값을 바로 함수의 스택 프레임에 저장하는 것이다. 함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초깃값을 상응하는 레지스터에 내용으로 복원하기만 하면 된다. 

### 스택 프레임과 스택 영역
스택 프레임은 스택 영역에 위치해 있다. 스택 영역은 프로세스 주소 공간의 일부이며, 스택 영역을 확대해 보면 레지스터 초깃값, 지역 변수, 매개 변수, 반환 주소를 담고 있다. 만약 어떤 함수가 자기 자신을 100,000,000 번 반복해서 호출한다면 함수가 매번 호출될 때마다 상응하는 스택 프레임은 함수 실행 시 정보를 저장하기 위해 실행되며, 함수 호출 단계가 증가함에 따라 스택 영역이 점점 더 많은 메모리를 차지하게 된다. 하지만 스택 영역의 크기에는 제한이 있으며, 이 제한을 초과하면 스택 넘친(stack overlfow) 오류가 발생한다. 따라서 프로그래머들은 너무 큰 지역 변수를 만들면 안 되고, 함수 호출 단계가 너무 많으면 안 된다. 매개 변수가 너무 많으면 일부 매개 변수가 스택에 저장되고, 레지스터 내용 중 일부는 스택 프레임에 저장된다. 그렇다면 매개변수가 너무 많아서 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까? 스택 영역의 증가와 감소는 구체적으로 어떻게 구현될까? 그리고 이를 구현한 책임은 누구에게 있을까? 프로세스 주소 공간으로 돌아가 스택 영역의 아래는 유휴 영역(free segment)이 존재한다. 스택 영역이 계속 증가하면 유휴 영역을 점유하기 시작하는데, 이 영역에도 물론 역할이 존재한다. 프로그램이 동적 라이브러리에 의존하는 경우에는 프로그램이 사용하는 동적 라이브러리가 이 영역에 적재된다. 

# 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?
스택 영역은 함수 호출과 밀접한 관련이 있다. 모든 함수에는 각자만의 스택 프레임이 있으며, 이 안에는 반환 주소, 함수의 지역 변수, 매개변수, 사용되는 레지스터를 비롯한 정보가 저장된다. 스택 프레임은 스택 영역 내에 구성되기 때문에 함수의 호출 단계가 증가할 때마다 스택 영역이 차지하는 메모리가 늘어난다. 반면에 함수 호출이 완료되면 기존 스택 프레임 정보는 더 이상 사용되지 않으므로 스택 영역이 차지하는 메모리는 그만큼 줄어든다. 프로그래머는 앞선 내용을 기반으로 두 가지 내용에 주의해야 한다.

1. 함수 A가 함수 B를 호출할 때, 함수 B에 대한 호출 과정이 완료되면 스택 프레임에 저장되어 있던 내용은 더 이상 사용되지 않고 무효화(invalidation)된다. 따라서 프로그래머는 무효화된 스택 프레임 내용에 대해 어떤 가정도 해서는 안 된다. 예를 들어 함수 B가 스택 프레임에 저장되어 있던 지역 변수 데이터에 대한 포인터를 반환하는 것처럼, 이미 사용이 끝난 스택 프레임 정보를 사용해서는 안 된다.
2. 지역 변수의 수명 주기(lifecycle)은 함수 호출과 동일하다. 이것의 장점은 프로그래머가 지역 변수가 차지하는 메모리의 할당과 반환 문제에 신경 쓸 필요가 없으며, 함수를 호출할 때 지역 변수가 바로 스택 프레임에 저장된다는 것이다. 함수 호출이 완료되면 스택 프레임 내용이 무효화되며, 스택 프레임이 사용하던 메모리를 다른 함수에서 가져와 사용할 수 있으므로, 이것이 직접 지역 변수가 사용할 메모리의 할당과 반환 문제에 신경을 쓸 필요가 없는 이유이다.반면이 지역 변수의 단점은 함수를 뛰어넘어 사용하는 것이 불가능하다는 것인데, 함수가 반환된 후에는 지역 변수가 저장되어 있던 메모리가 더 이상 유효하지 않기 때문이다. 동시에 이것은 지역 변수는 프로그래머의 관리 대상이 아니라는 것을 의미하기도 한다. 물론 함수 A가 함수 B를 호출한 상태에서 함수 B가 함수 A의 지역 변수를 사용하는 것처럼 지역 변수를 사용하는 시점에 해당 변수가 저장된 스택 프레임이 여전히 유효한 상태라는 것을 확인할 수 있다면, 함수 외부에서 지역 변수를 사용한 데 문제는 없다. 