# 비동기와 동기

## 전화 통화와 이메일 보내기
- 동기: 종속적, 연관된. 기다림. ex) 전화 통화에서의 대화
- 비동기: 비종속적, 무관한, 기다릴 필요 없는, 동시 발생 ex) 이메일 보내기 

## 동기 호출
funA의 함수가 funB를 호출하면, funB 함수 실행이 오나료될 때까지 funA 함수의 나머지 코드는 실행되지 않는다. 다시 말해 funA 함수는 반드시 funB 함수 실행이 완료될 때까지 기다려야 하며, 이것이 바로 동기 호출이다. 일반적으로 동기 호출에서는 funA 함수와 funB 함수가 동일한 스레드에서 실행되고, 이는 자주 볼 수 있는 상황이다. 

하지만 비교적 특수한 상황이 있는데, 입출력 작업이다. 
```
read(file, buf); // 여기에서 실행이 일시 중지된다.
// 파일 읽기가 완료될 때까지 기다렸다가 계속 실행한다. 
```
read 함수를 호출하여 파일을 읽는다고 가정할 때, 최하단 계층은 실제로 시스템 호 출(system call)로 운영 체제에 요청을 보낸다. 이때 운영 체제는 파일 읽기 작업을 위해 호출 스레드를 일시 중지시키며, 커널이 디스크 내용을 읽어 오면 일시 중지되었던 스레드가 다시 깨어난다. 이것이 바로 블로킹 입출력(blocking input/output)이다. 

물론 이것도 동기 호출이다. 단지 호출자와 파일을 읽는 코드가 다른 스레드에서 실행되고 있을 뿐이다. 따라서 동기 호출은 호출자와 수신자가 같은 스레드에서 실행 중인지 여부와는 관련이 없다. 

동기 프로그래밍은 프로그래머가 이해하기에 가장 쉽지만, 일부 상황에서 호출자가 요청한 작업이 끝날 때까지 기다려야 하기 때문에 효율은 높지 않다.

## 비동기 호출
- 일반적으로 비동기 호출은 디스크의 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업처럼 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행한다.
- 예를 들어 read 함수의 호출이 동기 방식일 경우에는 호출자는 파일을 모두 읽을 때까지 계속 진행이 불가능하지만, read 함수가 비동기 호출되면 파일 읽기 작업이 완료되지 않은 상태에서도 read 함수는 즉시 반환될 수 있다.
```
read(file, buff); // read 함수는 즉시 반환된다.
// 이후 내용의 실행을 블로킹하지 않는다.
```
이 경우 호출자가 블로킹되지 않고 read 함수가 즉시 반환되기 때문에, 호출자는 즉시 다음 작업을 실행할 수 있다. 호출자의 이후 작업은 파일 읽기 작업과 동시에 진행되기 때문에, 비동기의 높은 효율성을 가지고 온다.
그러나 비동기 호출은 프로그래머가 이해하는 데 큰 부담이 될 수 있으며, 코드를 작성하는 것도 그렇다. 

동기 호출 방식에서는 해당 함수가 반환될 때 호출된 함수와 관련된 작업 처리가 모두 완료되었다고 확신할 수 있다. 다시 말해 read 함수를 동기 호출하면, 해당 함수가 반환될 때 파일 읽기 작업이 모두 완료되었음을 의미한다. 하지만 비동기 호출에서는 어떨까? 비동기 호출의 결과를 처리할 때는 두 가지 상황이 있을 수 있다.
- 호출자가 실행 결과를 전혀 신경 쓰지 않을 때: 콜백 함수로 핸들러를 넘긴다. 요청 처리와 콜백 실행을 호출되는 스레드에서 처리한다.
- 호출자가 실행 결과를 반드시 알아야 할 때: 호출되는 스레드에서 요청 처리를 한 후에 결과를 통지해주면, 호출하는 스레드에서 결과를 처리한다.

첫 번째 상황을 구현하기 위해 콜백 함수를 사용할 수 있다. 예를 들어서, read 함수를 비동기 호출할 때 파일 내용을 처리하는 함수를 함께 매개변수로 전달할 수 있다. 

```
void handler(void*buf) {
    ... // 파일 내용 처리 중
}
read(buf, handler);
```
read(buf, handler)의 의미는 다음과 같다. '계속해서 파일을 읽고, 작업이 오나료되면 전달된 함수를 사용해서 파일을 처리해 주세요.' 이때, 파일 내용은 호출자 스레드가 아닌 콜백 함수가 실행되는 다른 스레드, 혹은 프로세스 등에서 처리한다. 

두 번째 상황을 구현하는 방법 중 하나는 알림(notification) 작동 방식을 사용하는 것이다. 즉, 작업 실행이 완료되면 호출자에게 작업 완료를 알리는 신호나 메시지를 보내는 것이다. 이 경우 결과 처리는 이전과 마찬가지로 호출 스레드에서 한다. 일반적으로 함수의 비동기 호출에는 흔히 스레드 두 개가 사용되는데, 호출자가 하나의 스레드를 사용하고 실제 작업은 일반적으로 다른 스레드에서 실행된다. 즉, 호출하는 스레드에서 호출을 하면 호출되는 스레드에서 요청 처리를 하고, 결과를 통지하면 결과 처리는 다시 호출하는 스레드에서 하는 것이다. 
