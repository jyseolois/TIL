# 콜백 함수

## 요구
만약 새로운 요청이 있을 때마다 함수 안에 if-else문이 추가되어야 한다면, 그때마다 코드를 계속 수정해야 하고, 이는 매우 잘못된 설계이다.

```
void make_donut() {
	if(CounA) {
		formed_A()
	} else if (Count) {
		formed_B()
	} else if….....
}
```

## 콜백이 필요한 이유
함수에 매개변수로 함수를 전달하도록 한다면 코드를 계속 수정할 필요가 없다. 이렇게 변수처럼 매개변수로 넘겨서 사용할 수 있는 함수는 ‘콜백 함수’이고, 일반적으로 콜백 함수는 직접 구현하지만 호출하는 것은 보통 다른 모듈이나 스레드이다.

```
void make_donut(fun f) {
	f()
}
// 콜백 함수
void formed_C() 
make_donut(formed_C);
```

## 비동기 콜백
만약 도넛 사업이 인기가 많아서 주문량이 증가하고 make_donut() 함수의 실행 시간도 점점 더 길어진다면 어떤 문제가 발생할까? 만약 해당 함수가 반환하는데 30분이 걸린다면, 그 밑의 함수가 실행되지 못하는 상황이 발생한다.

```
make_donut(formed_D);
something_important();
```

만약 이 줄이 너무 중요해서 30분 동안 기다릴 수 없다면 어떻게 이 문제를 개선할 수 있을까?

```
void real_make_donut(func f) {
	f();
}
void make_donut(func f) {
	thread t(real_make_donut, f);
}
```

make_donut 함수를 수정해서 함수 내부에서 스레드를 생성하고, 해당 스레드가 실제 도넛을 생성하게 할 수 있다. 이렇게 하면 이제 make_donut 함수를 호출하면 해당 함수는 새로운 스레드 t를 생성하고 나서 즉시 반환되고, 이후 something_important() 줄을 실행할 수 있다. 하지만 이때 중요한 점은, something_important() 줄의 코드가 실행 될 때 실제 도넛 생성 작업은 아직 시작되지 않았을 수 있다는 것이다. 이것이 바로 비동기(asynchronization)이다. 

이렇게 하면 make_donut 함수를 호출하고 나서 30분 동안 기다릴 필요가 없으며, 호출자와 피호출자가 각자의 스레드에서 병렬로 실행될 수 있다.

- 이처럼 **호출 스레드가 콜백 함수 실행에 의존하지 않는 것을 비동기 콜백(asynchronous callback)**이라고 한다. 